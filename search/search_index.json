{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Homepage","text":"<p>Serverless Rules are a compilation of rules to validate infrastructure-as-code template against recommended practices. This currently provides a module for cfn-lint and a plugin for tflint.</p> <p>You can use those rules to get quick feedback on recommended practices while building a serverless application, as part of an automated code review process, or as guardrails before deploying to production.</p> <p>Public preview</p> <p>This project is currently in public preview to get feedback from the serverless community. APIs, tools, and rules might change between the beginning of public preview and version 1.</p>"},{"location":"#current-modules-and-plugins","title":"Current modules and plugins","text":"<ul> <li>The <code>cfn-lint</code> module supports checking CloudFormation and Serverless Application Model (SAM) templates. It also supports templates defined with the AWS Cloud Development Kit (CDK) and the Serverless Framework by synthesizing to CloudFormation.</li> <li>The <code>tflint</code> plugin supports checking Terraform configuration files.</li> </ul> <p>If you would like native support for other frameworks, please consider adding a \ud83d\udc4d reaction to the corresponding comment in this GitHub issue.</p>"},{"location":"#usage","title":"Usage","text":"<p>To learn how to use Serverless Rules, see the detailed usage guide for each plugin:</p> <ul> <li>With <code>cfn-lint</code></li> <li>With <code>tflint</code></li> </ul>"},{"location":"#frequently-asked-questions","title":"Frequently asked questions","text":""},{"location":"#can-i-ignore-some-of-the-rules-in-this-project","title":"Can I ignore some of the rules in this project?","text":"<p>Serverless Rules is a set of recommended practices. </p> <p>We recommend you to keep Error-level rules enabled. Non-error rules, for example Lambda Tracing, contain detailed scenarios on when it\u2019s safe to ignore them.</p> <p>When needed, you can ignore any specific rule that doesn\u2019t match your environment.</p>"},{"location":"#how-is-this-different-from-cfn-lint-or-tflint-ruleset-aws","title":"How is this different from <code>cfn-lint</code> or <code>tflint-ruleset-aws</code>?","text":"<p><code>cfn-lint</code> and <code>tflint</code> main goals are to find possible errors in templates and configuration files before you try to deploy resources to AWS. By comparison, Serverless Rules goes one step further by providing prescriptive guidance based on the AWS Well-Architected pillars.</p> <p>For example, you can define AWS Lambda functions without tracing enabled, which is valid for both CloudFormation and Terraform. This project adds a rule on Lambda tracing as a recommended practice for Operational Excellence.</p>"},{"location":"#why-use-cfn-lint-instead-of-cfn-guard-or-cfn_nag","title":"Why use <code>cfn-lint</code> instead of <code>cfn-guard</code> or <code>cfn_nag</code>?","text":"<p><code>cfn-guard</code> provides developers with a simplified language to define polices and validate JSON- or YAML- formatted documents. You can use that tool to create your own rules that match your compliance needs or internal recommended practices. <code>cfn_nag</code> provides a set of default rules with a strong focus on security. You can extend it in ruby to create custom rules.</p> <p>By comparison, <code>cfn-lint</code> provides a set of default rules focused on validating templates against the CloudFormation resource specification and you can create your own rule with Python modules.</p> <p>For Serverless Rules, using a programming language like Python or Ruby gives more flexibility when defining complex rules integrating multiple resources, such as checking if a Lambda function has a log group with retention configured.</p>"},{"location":"cfn-lint/","title":"<code>cfn-lint</code> module","text":""},{"location":"cfn-lint/#installation","title":"Installation","text":"<p>Serverless Rules for <code>cfn-lint</code> is available through the <code>cfn-lint-serverless</code> Python module in PyPi. You can use pip to install the module:</p> <pre><code>pip install cfn-lint cfn-lint-serverless\n</code></pre>"},{"location":"cfn-lint/#usage","title":"Usage","text":"<p>You can now instruct <code>cfn-lint</code> to use Serverless Rules installed previous via <code>--append-rules</code>, or <code>-a</code> for short:</p> <pre><code>cfn-lint my_template.yaml -a cfn_lint_serverless.rules\n</code></pre> <p>You can also try with a Serverless Application Model (SAM) example provided in this repository. In the root folder of the repository, you can run:</p> <pre><code>cfn-lint examples/sam/template.yaml -a cfn_lint_serverless.rules\n</code></pre>"},{"location":"cfn-lint/#sample-outputs","title":"Sample outputs","text":"<p>If the template fulfills the requirements for all rules, <code>cfn-lint</code> will return an empty output. Otherwise, <code>cfn-lint</code> will output recommendations.</p> Matching templateWith recommendations <pre><code>$ cfn-lint template.yaml -a cfn_lint_serverless.rules\n$\n</code></pre> <pre><code>$ cfn-lint template.yaml -a cfn_lint_serverless.rules\nES4000 EventBridge rule ConsumerFunctionTrigger should have a DeadLetterConfig.Arn property for all its Targets.\ntemplate.yaml:5:1\n\nWS1000 Lambda function ConsumerFunction should have Tracing property set to 'Active'.\ntemplate.yaml:7:3\n\nWS1004 Lambda function ConsumerFunction does not have a corresponding log group with a Retention property\ntemplate.yaml:7:3\n$\n</code></pre>"},{"location":"cfn-lint/#ignoring-rules","title":"Ignoring rules","text":"<p>Serverless Rules is a set of recommended practices. </p> <p>We recommend you to keep Error-level rules enabled. Non-error rules, for example Lambda Tracing, contain detailed scenarios on when it\u2019s safe to ignore them.</p> <p>When needed, you can ignore any specific rule that doesn\u2019t match your environment.</p> <p>Rules in <code>cfn-lint</code> can be disabled either through the <code>--ignore-checks</code>/<code>-i</code> command line argument, or with the <code>.cfnlintrc</code> configuration file in the current working directory. See the <code>cfn-lint</code> documentation for more information.</p> Command line.cfnlintrc <pre><code># Disable rule WS1000\ncfn-lint my_template.yaml -a cfn_lint_serverless.rules -i WS1000\n</code></pre> <pre><code>ignore_checks:\n  # Disable rule WS1000\n  - WS1000\n</code></pre>"},{"location":"cfn-lint/#other-frameworks","title":"Other frameworks","text":"<p>You can use the <code>cfn-lint</code> module with all frameworks that synthesize to a CloudFormation template, such as the AWS Cloud Development Kit (CDK) and the Serverless Framework.</p>"},{"location":"cfn-lint/#cdk","title":"CDK","text":"<p>With the AWS CDK, you define your cloud resources using a familiar programming language such as TypeScript, Python, Java, C#/.Net, or Go. It will then use CloudFormation to provision those resources in your AWS environments.</p> <p>Under the hood, CDK will generate a CloudFormation template before initiating a deployment on AWS. You can use the <code>cdk synth</code> command to generate that template manually. You can then run <code>cfn-lint</code> for inspecting that template.</p> <pre><code>cdk synth &gt; template.yaml\ncfn-lint template.yaml -a cfn_lint_serverless.rules\n</code></pre> <p>You can also try with a CDK example provided in this repository. In the root folder of the repository, you can run:</p> <pre><code>cd examples/cdk/\ncdk synth &gt; template.yaml\ncfn-lint template.yaml -a cfn_lint_serverless.rules\n</code></pre>"},{"location":"cfn-lint/#serverless-framework","title":"Serverless Framework","text":"<p>The Serverless Framework is a specialized framework for Serverless applications that uses CloudFormation under the hood when deploying resources to AWS. You can manually create a package using the <code>sls package</code> command, which will generate the CloudFormation templates. With the <code>--package</code> option, you can specify in which folder it will store your package. In that folder, you can find the CloudFormation templates as JSON files starting with <code>cloudformation-template-</code>. You can then run <code>cfn-lint</code> for inspecting those templates.</p> <pre><code>sls package --package output/\ncfn-lint output/cloudformation-template-*.json -a cfn_lint_serverless.rules\n</code></pre>"},{"location":"cfn-lint/#continuous-integration","title":"Continuous integration","text":"<p>You can use Serverless Rules and <code>cfn-lint</code> with your continuous integration tool to automatically check CloudFormation templates with rules from this project. For example, you can validate on pull requests, merge to your main branch, or before deploying to production.</p> <p>If there are any issues with your template, <code>cfn-lint</code> will return a non-zero error code. You can find more information about <code>cfn-lint</code> return codes in its documentation.</p>"},{"location":"cfn-lint/#aws-codebuild","title":"AWS CodeBuild","text":"<p>Assuming that you are storing your template as <code>template.yaml</code> at the root of your repository, you can create a buildspec file such as this one:</p> Sample buildspecWith JUnit report <pre><code>version: 0.2\n\nphases:\n  install:\n    runtime-versions:\n      python: \"3.13\"\n    commands:\n      # Install cfn-lint-serverless\n      - pip install cfn-lint cfn-lint-serverless\n  pre_build:\n    commands:\n      # TODO: replace here with your template name if you are not\n      # using 'template.yaml'.\n      - cfn-lint template.yaml -a cfn_lint_serverless.rules\n</code></pre> <pre><code>version: 0.2\n\nphases:\n  install:\n    runtime-versions:\n      python: \"3.13\"\n    commands:\n      # Install cfn-lint-serverless\n      - pip install cfn-lint cfn-lint-serverless\n  pre_build:\n    commands:\n      # TODO: replace here with your template name if you are not\n      # using 'template.yaml'.\n      - cfn-lint template.yaml -a cfn_lint_serverless.rules -f junit --output-file cfn_lint_report.xml\n\nreports:\n  cfn-lint:\n    files:\n      - cfn_lint_report.xml\n</code></pre> <p>If you want to run <code>cfn-lint</code> with other frameworks, see how you can generate CloudFormation templates in the Other frameworks section of this documentation.</p>"},{"location":"cfn-lint/#github-actions","title":"GitHub Actions","text":"<p>Assuming that your template is stored as <code>template.yaml</code> at the root of your repository and that you are using <code>main</code> as your target branch for pull requests, you can create a GitHub actions workflow file such as this one:</p> Sample workflowWith JUnit report <pre><code>name: cfn-lint-serverless\n\non:\n  pull_request:\n    branches:\n      # TODO: replace this if you are not using 'main' as your target\n      # branch for pull requests.\n      - main\n\njobs:\n  cfn-lint-serverless:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Set up Python 3.13\n        uses: actions/setup-python@v5\n        with:\n          python-version: \"3.13\"\n      - name: Install cfn-lint-serverless\n        # Install cfn-lint-serverless\n        run: pip install cfn-lint cfn-lint-serverless\n      - name: Lint CloudFormation template\n        # TODO: replace here with your template name if you are not\n        # using 'template.yaml'.\n        run: cfn-lint template.yaml -a cfn_lint_serverless.rules\n</code></pre> <pre><code>name: cfn-lint-serverless\n\non:\n  pull_request:\n    branches:\n      # TODO: replace this if you are not using 'main' as your target\n      # branch for pull requests.\n      - main\n\njobs:\n  cfn-lint-serverless:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Set up Python 3.13\n        uses: actions/setup-python@v5\n        with:\n          python-version: \"3.13\"\n      - name: Install cfn-lint-serverless\n        # Install cfn-lint-serverless\n        run: pip install cfn-lint cfn-lint-serverless\n      - name: Lint CloudFormation template\n        # TODO: replace here with your template name if you are not\n        # using 'template.yaml'.\n        run: cfn-lint template.yaml -a cfn_lint_serverless.rules -f junit --output-file cfn_lint_report.xml\n        # Annotate PR based on cfn-lint's findings\n      - name: Publish test report\n        uses: mikepenz/action-junit-report@v4\n        # Only run this step on failure\n        if: ${{ failure() }}\n        with:\n          report_paths: cfn_lint_report.xml\n</code></pre> <p>If you want to run <code>cfn-lint</code> with other frameworks, see how you can generate CloudFormation templates in the Other frameworks section of this documentation.</p>"},{"location":"cfn-lint/#gitlab","title":"GitLab","text":"<p>Assuming that your template is stored as <code>template.yaml</code> at the root of your repository, you can create a <code>.gitlab-ci.yml</code> file such as this one:</p> Sample fileWith JUnit report <pre><code>cfn-lint-serverless:\n  image: python:latest\n  only:\n    - merge_requests\n  script:\n    # Install cfn-lint-serverless\n    - pip install cfn-lint cfn-lint-serverless\n    # TODO: replace here with your template name if you are not\n    # using 'template.yaml'.\n    - cfn-lint template.yaml -a cfn_lint_serverless.rules\n</code></pre> <pre><code>cfn-lint-serverless:\n  image: python:latest\n  only:\n    - merge_requests\n  script:\n    # Install cfn-lint-serverless\n    - pip install cfn-lint cfn-lint-serverless\n    # TODO: replace here with your template name if you are not\n    # using 'template.yaml'.\n    - cfn-lint template.yaml -a cfn_lint_serverless.rules -f junit --output-file cfn_lint_report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: cfn_lint_report.xml\n</code></pre> <p>If you want to run <code>cfn-lint</code> with other frameworks, see how you can generate CloudFormation templates in the Other frameworks section of this documentation.</p>"},{"location":"cfn-lint/#existing-stacks","title":"Existing stacks","text":"<p>If you want to check if a stack already deployed to AWS matches the recommended practices from Serverless Rules, you can download the CloudFormation template and run <code>cfn-lint</code> locally.</p> Existing stack <pre><code>STACK_NAME=\"your-cloudformation-stack-name\"\n\n# Retrieve the template from AWS CloudFormation\naws cloudformation get-template \\\n    --stack-name $STACK_NAME \\\n    --query 'TemplateBody' &gt; template.json\n\n# Run cfn-lint\ncfn-lint template.json -a cfn_lint_serverless.rules\n</code></pre>"},{"location":"cfn-lint/#ide-integration","title":"IDE integration","text":""},{"location":"cfn-lint/#visual-studio-code","title":"Visual Studio Code","text":"<p>For Visual Studio Code, you can add the CloudFormation Linter extension, which will automatically run <code>cfn-lint</code> on your CloudFormation templates. In the extension's <code>settings.json</code> file, you can add additional rules like so:</p> Extension settings <pre><code>{\n  // ... other settings omitted\n\n  \"cfnLint.appendRules\": [\n    \"cfn_lint_serverless.rules\"\n  ]\n}\n</code></pre>"},{"location":"tflint/","title":"<code>tflint</code> plugin","text":""},{"location":"tflint/#installation","title":"Installation","text":"<p>This plugin depends on tflint. If you use <code>tflint</code> version 0.29 or newer, you can leverage the <code>tflint --init</code> command to automatically install the plugin. Otherwise, you will need to download the <code>tflint-ruleset-aws-serverless</code> binary corresponding to your system from the releases page.</p> <p>You can enable the Serverless Rules plugin by adding a plugin section in the <code>.tflint.hcl</code> file in your project:</p> <pre><code>plugin \"aws-serverless\" {\n  enabled = true\n  version = \"0.3.5\"\n  source = \"github.com/awslabs/serverless-rules\"\n}\n</code></pre>"},{"location":"tflint/#usage","title":"Usage","text":"<p>You can now run the <code>tflint</code> command, which will automatically use the Serverless Rules plugin:</p> <pre><code>tflint\n</code></pre> <p>You can also try with a Terraform example provided in this repository. From the root folder of the repository, you can run:</p> <pre><code>cd examples/tflint/\ntflint \n</code></pre>"},{"location":"tflint/#sample-outputs","title":"Sample outputs","text":"<p>If the Terraform configuration files fulfill the requirements for all the rules, <code>tflint</code> will return an empty output. Otherwise, <code>tflint</code> will output recommendations.</p> Matching templateWith recommendations <pre><code>$ tflint\n$\n</code></pre> <pre><code>$ tflint\n1 issue(s) found:\n\nWarning: \"tracing_config\" is not present. (aws_lambda_function_tracing_rule)\n\n    on main.tf line 20:\n\n$\n</code></pre>"},{"location":"tflint/#ignoring-rules","title":"Ignoring rules","text":"<p>Serverless Rules is a set of recommended practices. </p> <p>We recommend you to keep Error-level rules enabled. Non-error rules, for example Lambda Tracing, contain detailed scenarios on when it\u2019s safe to ignore them.</p> <p>When needed, you can ignore any specific rule that doesn\u2019t match your environment.</p> <p>Rules in <code>tflint</code> can be disabled either through the <code>--disable-rule</code> command-line argument or with the <code>.tflint.hcl</code> configuration file in the current working directory. See the <code>tflint</code> user guide for more information.</p> Command line.tflint.hcl <pre><code># Disable the aws_lambda_function_tracing_rule rule\ntflint --disable-rule aws_lambda_function_tracing_rule\n</code></pre> <pre><code>plugin \"aws-serverless\" {\n  enabled = true\n  version = \"0.3.5\"\n  source = \"github.com/awslabs/serverless-rules\"\n}\n\n# Disable the aws_lambda_function_tracing_rule rule\nrule \"aws_lambda_function_tracing_rule\" {\n  enabled = false\n}\n</code></pre>"},{"location":"tflint/#continuous-integration","title":"Continuous integration","text":"<p>You can use Serverless Rules and <code>tflint</code> with your continuous integration tool to automatically check CloudFormation templates with rules from this project. For example, you can validate on pull requests, merge to your main branch, or before deploying to production.</p> <p>If there are any issues with your template, <code>tflint</code> will return a non-zero error code.</p>"},{"location":"tflint/#aws-codebuild","title":"AWS CodeBuild","text":"<p>Assuming that you are storing your terraform configuration files and a <code>.tflint.hcl</code> file at the root of your repository, you can create a buildspec file such as this one.</p> <p>Important</p> <p>Make sure that you include the aws-serverless plugin into your <code>.tflint.hcl</code> configuration file, otherwise tflint will not install this ruleset. See Installation for more information.</p> Sample buildspecWith JUnit report <pre><code>env:\n  variables:\n    # TODO: replace \"v0.61.0\" with the latest version of tflint\n    TFLINT_VERSION: \"0.61.0\"\n    TFLINT_OS: \"amd64\"\n\nphases:\n  install:\n    commands:\n      # Install tflint\n      - wget https://github.com/terraform-linters/tflint/releases/download/v${TFLINT_VERSION}/tflint_linux_${TFLINT_OS}.zip -O tflint.zip\n      - unzip tflint.zip\n      # Install tflint plugins\n      - ./tflint --init\n  pre_build:\n    commands:\n      - ./tflint\n</code></pre> <pre><code>env:\n  variables:\n    # TODO: replace \"v0.61.0\" with the latest version of tflint\n    TFLINT_VERSION: \"0.61.0\"\n    TFLINT_OS: \"amd64\"\n\nphases:\n  install:\n    commands:\n      # Install tflint\n      - wget https://github.com/terraform-linters/tflint/releases/download/v${TFLINT_VERSION}/tflint_linux_${TFLINT_OS}.zip -O tflint.zip\n      - unzip tflint.zip\n      # Install tflint plugins\n      - ./tflint --init\n  pre_build:\n    commands:\n      - ./tflint -f junit &gt; tflint_report.xml\n\nreports:\n  tflint:\n    files:\n      - tflint_report.xml\n</code></pre>"},{"location":"tflint/#github-actions","title":"GitHub Actions","text":"<p>Assuming that you are storing your terraform configuration files and a <code>.tflint.hcl</code> file at the root of your repository, and that you are using <code>main</code> as your target branch for pull requests, you can create a GitHub actions workflow file such as this one:</p> <p>Important</p> <p>Make sure that you include the aws-serverless plugin into your <code>.tflint.hcl</code> configuration file, otherwise tflint will not install this ruleset. See Installation for more information.</p> Sample workflowWith JUnit report <pre><code>name: tflint-serverless\n\non:\n  pull_request:\n    branches:\n      # TODO: replace this if you are not using 'main' as your target\n      # branch for pull requests.\n      - main\n\njobs:\n  tflint-serverless:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup TFLint\n        uses: terraform-linters/setup-tflint@v4\n        with:\n          tflint_version: v0.61.0\n      - name: Install Terraform plugins\n        run: tflint --init\n      - name: Lint Terraform files\n        run: tflint\n</code></pre> <pre><code>name: tflint-serverless\n\non:\n  pull_request:\n    branches:\n      # TODO: replace this if you are not using 'main' as your target\n      # branch for pull requests.\n      - main\n\njobs:\n  tflint-serverless:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup TFLint\n        uses: terraform-linters/setup-tflint@v4\n        with:\n          tflint_version: v0.61.0\n      - name: Install Terraform plugins\n        run: tflint --init\n      - name: Lint Terraform files\n        run: tflint -f junit &gt; tflint_report.xml\n      - name: Publish test report\n        uses: mikepenz/action-junit-report@v4\n        # Only run this step on failure\n        if: ${{ failure() }}\n        with:\n          report_paths: cfn_lint_report.xml\n</code></pre>"},{"location":"tflint/#gitlab","title":"GitLab","text":"<p>Assuming that you are storing your terraform configuration files and a <code>.tflint.hcl</code> file at the root of your repository, you can create a <code>.gitlab-ci.yml</code> file such as this one:</p> Sample fileWith JUnit report <pre><code>tflint-serverless:\n  variables:\n    # TODO: replace \"v0.61.0\" with the latest version of tflint\n    TFLINT_VERSION: \"0.61.0\"\n    TFLINT_OS: \"amd64\"\n  only:\n    - merge_requests\n  script:\n    # Install tflint\n    - wget https://github.com/terraform-linters/tflint/releases/download/v${TFLINT_VERSION}/tflint_linux_${TFLINT_OS}.zip -O tflint.zip\n    - unzip tflint.zip\n    # Install tflint plugins\n    - ./tflint --init\n    # Run tflint\n    - ./tflint\n</code></pre> <pre><code>tflint-serverless:\n  variables:\n    # TODO: replace \"v0.61.0\" with the latest version of tflint\n    TFLINT_VERSION: \"0.61.0\"\n    TFLINT_OS: \"amd64\"\n  only:\n    - merge_requests\n  script:\n    # Install tflint\n    - wget https://github.com/terraform-linters/tflint/releases/download/v${TFLINT_VERSION}/tflint_linux_${TFLINT_OS}.zip -O tflint.zip\n    - unzip tflint.zip\n    # Install tflint plugins\n    - ./tflint --init\n    # Run tflint\n    - ./tflint -f junit &gt; tflint_report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: tflint_report.xml\n</code></pre>"},{"location":"contributing/create_rule/","title":"Creating rules","text":"<p>If you are thinking of creating or proposing a new rule, please follow the process outline below. The first step before adding a new rule is to submit an issue to collect feedback from other members of the community.</p>"},{"location":"contributing/create_rule/#create-an-issue","title":"Create an issue","text":"<p>Before starting the implementation of a new rule, please create an issue using the New rule template. This will allow members of the community to provide feedback on its implementation, if it meets the needs of most serverless users, if it's the right level, etc.</p>"},{"location":"contributing/create_rule/#template-for-cfn-lint-rules","title":"Template for <code>cfn-lint</code> rules","text":"<pre><code># TODO: set the rule name\nclass __Rule(CloudFormationLintRule):\n    # TODO: set docstring\n    \"\"\"\n    Ensure that ...\n    \"\"\"\n\n    # TODO: update these values\n    id = \"...\" # noqa: N815\n    shortdesc = \"...\"\n    description = \"Ensure that ...\"\n    source_url = \"...\"\n    tags = [\"lambda\"]\n\n    _message = \"... {} ...\"\n\n    def match(self, cfn):\n        # TODO: update docstring\n        \"\"\"\n        Match against ...\n        \"\"\"\n\n        matches = []\n\n        # TODO: set resource type\n        for key, value in cfn.get_resources([\"...\"]).items():\n            # TODO: set property name\n            prop = value.get(\"Properties\", {}).get(\"...\", None)\n\n            if prop is None:\n                matches.append(RuleMatch([\"Resources\", key], self._message.format(key)))\n\n        return matches\n</code></pre>"},{"location":"contributing/create_rule/#template-for-documentation","title":"Template for documentation","text":"<p>Please use the following template when writing documentation for a rule. Each rule goes into a separate markdown file into the relevant service folder. For example, a rule for AWS Lambda would go into the <code>docs/rules/lambda/</code> folder.</p> <pre><code># _Service Name Rule name_\n\n__Level__: _Rule level_\n{: class=\"badge badge-red\" }\n\n__Initial version__: _release version_\n{: class=\"badge badge-blue\" }\n\n__cfn-lint__: _cfn-lint rule ID_\n{: class=\"badge\" }\n\n__tflint__: _tflint rule name_\n{: class=\"badge\" }\n\n_Short explanation on the rule_\n\n## Implementations\n\n=== \"CDK\"\n\n    ```typescript\n    // Imports here\n\n    export class MyStack extends cdk.Stack {\n      constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {\n        super(scope, id, props);\n\n        // Implementation\n      }\n    }\n    ```\n\n=== \"CloudFormation (JSON)\"\n\n    ```json\n    {\n      \"Resources\": {\n        // Add resources here\n      }\n    }\n    ```\n\n=== \"CloudFormation (YAML)\"\n\n    ```yaml\n    Resources:\n      # Add resources here\n    ```\n\n=== \"Serverless Framework\"\n\n    ```yaml\n    provider:\n      name: aws\n      # Add provider-specific configuration here\n\n    resources:\n      # Add resources here\n    ```\n\n=== \"Terraform\"\n\n    ```tf\n    # Add Terraform resources here\n    ```\n\n## See also\n\n* _List of links to the relevant documentation, from sources such as AWS Well-Architected, service documentation, etc._\n</code></pre>"},{"location":"rules/","title":"Rules","text":""},{"location":"rules/#rule-levels","title":"Rule levels","text":"<p>A rule can have one of the following three rule levels: Error, Warning, or Info.</p> <p>An Error level for a rule means this is a recommended practice for the vast majority of circumstances.</p> <p>A Warning level means that this is a recommended practice, but you can achieve similar results through a different implementation. For example, you can create alarms through third party offering, rather than using AWS CloudWatch.</p> <p>An Info level means that this does not necessarily align with recommended practices but can point out potential issues or misconfiguration. For example, an Amazon EventBridge event bus without any rules associated with it, as you might create those rules through a different template.</p>"},{"location":"rules/#aws-lambda","title":"AWS Lambda","text":"Level Name cfn-lint tflint Warning Lambda Tracing WS1000 aws_lambda_function_tracing_rule Error EventSourceMapping Failure Destination ES1001 aws_lambda_event_source_mapping_failure_destination Warning Lambda Permission Multiple Principals WS1002 aws_lambda_permission_multiple_principals Warning Lambda Star Permissions WS1003 aws_iam_role_lambda_no_star Warning Lambda Log Retention WS1004 aws_cloudwatch_log_group_lambda_retention Error Lambda Default Memory Size ES1005 aws_lambda_function_default_memory Error Lambda Default Timeout ES1006 aws_lambda_function_default_timeout Error Async Lambda Failure Destination ES1007 aws_lambda_event_invoke_config_async_on_failure Error Lambda EOL Runtime E2531 aws_lambda_function_eol_runtime"},{"location":"rules/#amazon-api-gateway-rest-apis","title":"Amazon API Gateway REST APIs","text":"Level Name cfn-lint tflint Error API Gateway Logging ES2000 aws_apigateway_stage_logging_rule Warning API Gateway Structured Logging WS2001 aws_api_gateway_stage_structured_logging Warning API Gateway Tracing WS2002 aws_apigateway_stage_tracing_rule Warning API Gateway Default Throttling ES2003 aws_apigateway_stage_throttling_rule"},{"location":"rules/#amazon-api-gateway-http-apis","title":"Amazon API Gateway HTTP APIs","text":"Level Name cfn-lint tflint Error API Gateway Logging ES2000 aws_apigatewayv2_stage_logging_rule Warning API Gateway Structured Logging WS2001 aws_apigatewayv2_stage_structured_logging Warning API Gateway Default Throttling ES2003 aws_apigatewayv2_stage_throttling_rule"},{"location":"rules/#aws-appsync","title":"AWS AppSync","text":"Level Name cfn-lint tflint Error AppSync Tracing WS3000 aws_appsync_graphql_api_tracing_rule"},{"location":"rules/#amazon-eventbridge","title":"Amazon EventBridge","text":"Level Name cfn-lint tflint Error EventBridge Rule Without DLQ ES4000 aws_cloudwatch_event_target_no_dlq"},{"location":"rules/#amazon-sns","title":"Amazon SNS","text":"Level Name cfn-lint tflint Error SNS Redrive Policy ES7000 aws_sns_topic_subscription_redrive_policy"},{"location":"rules/#amazon-sqs","title":"Amazon SQS","text":"Level Name cfn-lint tflint Error SQS Redrive Policy ES6000 aws_sqs_queue_redrive_policy"},{"location":"rules/#amazon-step-functions","title":"Amazon Step Functions","text":"Level Name cfn-lint tflint Warning Step Functions Tracing WS5000 aws_sfn_state_machine_tracing"},{"location":"rules/api_gateway/default_throttling/","title":"API Gateway Default Throttling","text":"<p>Level: Error</p> <p>Initial version: 0.1.3</p> <p>cfn-lint: ES2003</p> <p>tflint (REST): aws_apigateway_stage_throttling_rule</p> <p>tflint (HTTP): aws_apigatewayv2_stage_throttling_rule</p> <p>Amazon API Gateway supports defining default limits for an API to prevent it from being overwhelmed by too many requests. This uses a token bucket algorithm, where a token counts for a single request.</p>"},{"location":"rules/api_gateway/default_throttling/#implementations-for-rest-apis","title":"Implementations for REST APIs","text":"CDKCloudFormation (JSON)CloudFormation (YAML)Serverless FrameworkTerraform <pre><code>import { RestApi } from '@aws-cdk/aws-apigateway';\n\nexport class MyStack extends cdk.Stack {\n  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    const myApi = new RestApi(\n      scope, 'MyApi',\n      {\n        deployOptions: {\n          // Throttling for default methods\n          methodOptions: {\n            '*/*': {\n              throttlingBurstLimit: 1000,\n              throttlingRateLimit: 10,\n            }\n          }\n        },\n      }\n    );\n  }\n}\n</code></pre> <pre><code>{\n  \"Resources\": {\n    \"MyApi\": {\n      \"Type\": \"AWS::Serverless::Api\",\n      \"Properties\": {\n        \"DefinitionUri\": \"openapi.yaml\",\n        \"StageName\": \"prod\",\n        // Throttling for default methods by setting HttpMethod  to '*' and\n        // ResourcePath to '/*'\n        \"MethodSettings\": [{\n          \"HttpMethod\": \"*\",\n          \"ResourcePath\": \"/*\",\n          \"ThrottlingRateLimit\": 10,\n          \"ThrottlingBurstLimit\": 1000\n        }]\n      }\n    }\n  }\n}\n</code></pre> <pre><code>Resources:\n  MyApi:\n    Type: AWS::Serverless::Api\n    Properties:\n      DefinitionUri: openapi.yaml\n      StageName: prod\n\n      # Throttling for default methods by setting HttpMethod  to '*' and\n      # ResourcePath to '/*'\n      MethodSettings:\n        - HttpMethod: \"*\"\n          ResourcePath: \"/*\"\n          ThrottlingRateLimit: 10\n          ThrottlingBurstLimit: 1000\n</code></pre> <pre><code>resources:\n  Resources:\n    MyApi:\n      Type: AWS::Serverless::Api\n      Properties:\n        DefinitionUri: openapi.yaml\n        StageName: prod\n\n        # Throttling for default methods by setting HttpMethod  to '*' and\n        # ResourcePath to '/*'\n        MethodSettings:\n          - HttpMethod: \"*\"\n            ResourcePath: \"/*\"\n            ThrottlingRateLimit: 10\n            ThrottlingBurstLimit: 1000\n</code></pre> <pre><code>resource \"aws_api_gateway_stage\" \"this\" {\n  body = file(\"openapi.yaml\") \n}\n\nresource \"aws_api_gateway_deployment\" \"this\" {\n  rest_api_id = aws_api_gateway_rest_api.this.id\n\n  triggers = {\n    redeployment = sha1(jsonencode(aws_api_gateway_rest_api.this.body))\n  }\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n\nresource \"aws_api_gateway_stage\" \"this\" {\n  deployment_id = aws_api_gateway_deployment.this.id\n  rest_api_id   = aws_api_gateway_rest_api.this.id\n  stage_name    = \"prod\"\n}\n\n# Throttling for default methods by setting method_path to '*/*'\nresource \"aws_api_gateway_method_settings\" \"this\" {\n  rest_api_id = aws_api_gateway_rest_api.this.id\n  stage_name  = aws_api_gateway_stage.this.stage_name\n  method_path = \"*/*\"\n\n  settings {\n    throttling_burst_limit = 1000\n    throttling_rate_limit  = 10\n  }\n}\n</code></pre>"},{"location":"rules/api_gateway/default_throttling/#implementations-for-http-apis","title":"Implementations for HTTP APIs","text":"CDKCloudFormation (JSON)CloudFormation (YAML)Serverless FrameworkTerraform <p>Remark: this is currently not supported in AWS CDK as an L2 construct at the moment.</p> <pre><code>import { CfnStage, HttpApi } from '@aws-cdk/aws-apigatewayv2';\n\nexport class MyStack extends cdk.Stack {\n  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    const myApi = new HttpApi(\n      scope, 'MyApi'\n    );\n\n    // Throttling for default methods by setting method_path to '*/* using escape hatch.\n\n    // See https://docs.aws.amazon.com/cdk/latest/guide/cfn_layer.html#cfn_layer_resource\n    // for more information.\n    const defaultStage = myApi.defaultStage.node.defaultChild as CfnStage;\n    defaultStage.defaultRouteSettings = {\n      throttlingBurstLimit = 1000,\n      throttlingRateLimit = 10,\n    };\n  }\n}\n</code></pre> <pre><code>{\n  \"Resources\": {\n    \"MyApi\": {\n      \"Type\": \"AWS::Serverless::HttpApi\",\n      \"Properties\": {\n        \"DefinitionUri\": \"openapi.yaml\",\n        \"StageName\": \"prod\",\n        \"DefaultRouteSettings\": {\n          \"ThrottlingBurstLimit\": 1000,\n          \"ThrottlingRateLimit\": 10\n        }\n      }\n    }\n  }\n}\n</code></pre> <pre><code>Resources:\n  MyApi:\n    Type: AWS::Serverless::HttpApi\n    Properties:\n      DefinitionUri: \"openapi.yaml\"\n      StageName: prod\n      DefaultRouteSettings:\n        ThrottlingBurstLimit: 1000\n        ThrottlingRateLimit: 10\n</code></pre> <pre><code>resources:\n  Resources:\n    MyApi:\n      Type: AWS::Serverless::HttpApi\n      Properties:\n        DefinitionUri: \"openapi.yaml\"\n        StageName: prod\n        DefaultRouteSettings:\n          ThrottlingBurstLimit: 1000\n          ThrottlingRateLimit: 10\n</code></pre> <pre><code>resource \"aws_apigatewayv2_api\" \"this\" {\n  name          = \"my-api\"\n  protocol_type = \"HTTP\"\n  body          = file(\"openapi.yaml\") \n}\n\nresource \"aws_apigatewayv2_stage\" \"this\" {\n  api_id = aws_apigatewayv2_api.this.id\n  name   = \"prod\"\n\n  # Default throttling settings\n  default_route_settings {\n    throttling_burst_limit = 1000\n    throttling_rate_limit  = 10\n  }\n}\n</code></pre>"},{"location":"rules/api_gateway/default_throttling/#see-also","title":"See also","text":"<ul> <li>Throttle API requests for better throughput</li> <li>Throttling requests to your HTTP API</li> </ul>"},{"location":"rules/api_gateway/logging/","title":"API Gateway Logging","text":"<p>Level: Error</p> <p>Initial version: 0.1.3</p> <p>cfn-lint: ES2000</p> <p>tflint (REST): aws_apigateway_stage_logging_rule</p> <p>tflint (HTTP): aws_apigatewayv2_stage_logging_rule</p> <p>Amazon API Gateway can send logs to Amazon CloudWatch Logs and Amazon Kinesis Data Firehose for centralization.</p>"},{"location":"rules/api_gateway/logging/#implementations-for-rest-apis","title":"Implementations for REST APIs","text":"CDKCloudFormation (JSON)CloudFormation (YAML)Serverless FrameworkTerraform <pre><code>import { LogGroup } from '@aws-cdk/aws-logs';\nimport { LogGroupLogDestination, RestApi } from '@aws-cdk/aws-apigateway';\n\nexport class MyStack extends cdk.Stack {\n  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    const myLogGroup = new LogGroup(\n      scope, 'MyLogGroup'\n    );\n\n    const myApi = new RestApi(\n      scope, 'MyApi',\n      {\n        deployOptions: {\n          // Setup logging for API Gateway\n          accessLogDestination: new LogGroupLogDestination(myLogGroup),\n          accessLogFormat: JSON.stringify({\n            \"stage\" : \"$context.stage\",\n            \"request_id\" : \"$context.requestId\",\n            \"api_id\" : \"$context.apiId\",\n            \"resource_path\" : \"$context.resourcePath\",\n            \"resource_id\" : \"$context.resourceId\",\n            \"http_method\" : \"$context.httpMethod\",\n            \"source_ip\" : \"$context.identity.sourceIp\",\n            \"user-agent\" : \"$context.identity.userAgent\",\n            \"account_id\" : \"$context.identity.accountId\",\n            \"api_key\" : \"$context.identity.apiKey\",\n            \"caller\" : \"$context.identity.caller\",\n            \"user\" : \"$context.identity.user\",\n            \"user_arn\" : \"$context.identity.userArn\",\n            \"integration_latency\": $context.integration.latency\n          }),\n        }\n      }\n    );\n  }\n}\n</code></pre> <pre><code>{\n  \"Resource\": {\n    \"Type\": \"AWS::Serverless::Api\",\n    \"Properties\": {\n      \"DefinitionUri\": \"openapi.yaml\",\n      \"StageName\": \"prod\",\n\n      // Setup logging for API Gateway\n      \"AccessLogSetting\":{\n        \"DestinationArn\": \"arn:aws:logs:eu-west-1:123456789012:log-group:my-log-group\",\n        \"Format\": \"{ \\\"stage\\\" : \\\"$context.stage\\\", \\\"request_id\\\" : \\\"$context.requestId\\\", \\\"api_id\\\" : \\\"$context.apiId\\\", \\\"resource_path\\\" : \\\"$context.resourcePath\\\", \\\"resource_id\\\" : \\\"$context.resourceId\\\", \\\"http_method\\\" : \\\"$context.httpMethod\\\", \\\"source_ip\\\" : \\\"$context.identity.sourceIp\\\", \\\"user-agent\\\" : \\\"$context.identity.userAgent\\\", \\\"account_id\\\" : \\\"$context.identity.accountId\\\", \\\"api_key\\\" : \\\"$context.identity.apiKey\\\", \\\"caller\\\" : \\\"$context.identity.caller\\\", \\\"user\\\" : \\\"$context.identity.user\\\", \\\"user_arn\\\" : \\\"$context.identity.userArn\\\", \\\"integration_latency\\\": $context.integration.latency }\"\n      }\n    }\n  }\n}\n</code></pre> <pre><code>Resources:\n  Api:\n    Type: AWS::Serverless::Api\n    Properties:\n      DefinitionUri: openapi.yaml\n      StageName: prod\n\n      # Setup logging for API Gateway\n      AccessLogSetting:\n        DestinationArn: \"arn:aws:logs:eu-west-1:123456789012:log-group:my-log-group\"\n        Format: |\n          {\n            \"stage\" : \"$context.stage\",\n            \"request_id\" : \"$context.requestId\",\n            \"api_id\" : \"$context.apiId\",\n            \"resource_path\" : \"$context.resourcePath\",\n            \"resource_id\" : \"$context.resourceId\",\n            \"http_method\" : \"$context.httpMethod\",\n            \"source_ip\" : \"$context.identity.sourceIp\",\n            \"user-agent\" : \"$context.identity.userAgent\",\n            \"account_id\" : \"$context.identity.accountId\",\n            \"api_key\" : \"$context.identity.apiKey\",\n            \"caller\" : \"$context.identity.caller\",\n            \"user\" : \"$context.identity.user\",\n            \"user_arn\" : \"$context.identity.userArn\",\n            \"integration_latency\": $context.integration.latency\n          }\n</code></pre> <pre><code>provider:\n  name: aws\n  logs:\n    # Setup logging for API Gateway\n    restApi:\n      accessLogging: true\n      format: |\n        {\n          \"stage\" : \"$context.stage\",\n          \"request_id\" : \"$context.requestId\",\n          \"api_id\" : \"$context.apiId\",\n          \"resource_path\" : \"$context.resourcePath\",\n          \"resource_id\" : \"$context.resourceId\",\n          \"http_method\" : \"$context.httpMethod\",\n          \"source_ip\" : \"$context.identity.sourceIp\",\n          \"user-agent\" : \"$context.identity.userAgent\",\n          \"account_id\" : \"$context.identity.accountId\",\n          \"api_key\" : \"$context.identity.apiKey\",\n          \"caller\" : \"$context.identity.caller\",\n          \"user\" : \"$context.identity.user\",\n          \"user_arn\" : \"$context.identity.userArn\",\n          \"integration_latency\": $context.integration.latency\n        }\n</code></pre> <pre><code>resource \"aws_api_gateway_rest_api\" \"this\" {\n  body = file(\"openapi.yaml\")\n}\n\nresource \"aws_api_gateway_deployment\" \"this\" {\n  rest_api_id = aws_api_gateway_rest_api.this.id\n\n  triggers = {\n    redeployment = sha1(jsonencode(aws_api_gateway_rest_api.this.body))\n  }\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n\nresource \"aws_api_gateway_stage\" \"this\" {\n  deployment_id = aws_api_gateway_deployment.this.id\n  rest_api_id   = aws_api_gateway_rest_api.this.id\n  stage_name    = \"prod\"\n\n  # Setup logging for API Gateway\n  access_log_settings {\n    destination_arn = \"arn:aws:logs:eu-west-1:123456789012:log-group:my-log-group\"\n    format = &lt;&lt;EOF\n{\n  \"stage\" : \"$context.stage\",\n  \"request_id\" : \"$context.requestId\",\n  \"api_id\" : \"$context.apiId\",\n  \"resource_path\" : \"$context.resourcePath\",\n  \"resource_id\" : \"$context.resourceId\",\n  \"http_method\" : \"$context.httpMethod\",\n  \"source_ip\" : \"$context.identity.sourceIp\",\n  \"user-agent\" : \"$context.identity.userAgent\",\n  \"account_id\" : \"$context.identity.accountId\",\n  \"api_key\" : \"$context.identity.apiKey\",\n  \"caller\" : \"$context.identity.caller\",\n  \"user\" : \"$context.identity.user\",\n  \"user_arn\" : \"$context.identity.userArn\",\n  \"integration_latency\": $context.integration.latency\n}\nEOF\n  }\n}\n</code></pre>"},{"location":"rules/api_gateway/logging/#implementations-for-http-apis","title":"Implementations for HTTP APIs","text":"CDKCloudFormation (JSON)CloudFormation (YAML)Serverless FrameworkTerraform <p>Remark: this is currently not supported in AWS CDK as an L2 construct at the moment. See this GitHub issue for more details.</p> <pre><code>import { CfnStage, HttpApi } from '@aws-cdk/aws-apigatewayv2';\n\nexport class MyStack extends cdk.Stack {\n  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    const myApi = new HttpApi(\n      scope, 'MyApi'\n    );\n\n    // Setup logging for API Gateway using escape hatch.\n\n    // See https://github.com/aws/aws-cdk/issues/11100 and\n    // https://docs.aws.amazon.com/cdk/latest/guide/cfn_layer.html#cfn_layer_resource\n    // for more information.\n    const defaultStage = myApi.defaultStage.node.defaultChild as CfnStage;\n    defaultStage.accessLogSettings = {\n      destinationArn: '',\n      format: JSON.stringify({\n        \"stage\" : \"$context.stage\",\n        \"request_id\" : \"$context.requestId\",\n        \"api_id\" : \"$context.apiId\",\n        \"resource_path\" : \"$context.resourcePath\",\n        \"resource_id\" : \"$context.resourceId\",\n        \"http_method\" : \"$context.httpMethod\",\n        \"source_ip\" : \"$context.identity.sourceIp\",\n        \"user-agent\" : \"$context.identity.userAgent\",\n        \"account_id\" : \"$context.identity.accountId\",\n        \"api_key\" : \"$context.identity.apiKey\",\n        \"caller\" : \"$context.identity.caller\",\n        \"user\" : \"$context.identity.user\",\n        \"user_arn\" : \"$context.identity.userArn\",\n        \"integration_latency\": $context.integration.latency\n      }),\n    };\n  }\n}\n</code></pre> <pre><code>{\n  \"Resource\": {\n    \"Type\": \"AWS::Serverless::HttpApi\",\n    \"Properties\": {\n      \"DefinitionUri\": \"openapi.yaml\",\n      \"StageName\": \"prod\",\n\n      // Setup logging for API Gateway\n      \"AccessLogSettings\":{\n        \"DestinationArn\": \"arn:aws:logs:eu-west-1:123456789012:log-group:my-log-group\",\n        \"Format\": \"{ \\\"stage\\\" : \\\"$context.stage\\\", \\\"request_id\\\" : \\\"$context.requestId\\\", \\\"api_id\\\" : \\\"$context.apiId\\\", \\\"resource_path\\\" : \\\"$context.resourcePath\\\", \\\"resource_id\\\" : \\\"$context.resourceId\\\", \\\"http_method\\\" : \\\"$context.httpMethod\\\", \\\"source_ip\\\" : \\\"$context.identity.sourceIp\\\", \\\"user-agent\\\" : \\\"$context.identity.userAgent\\\", \\\"account_id\\\" : \\\"$context.identity.accountId\\\", \\\"api_key\\\" : \\\"$context.identity.apiKey\\\", \\\"caller\\\" : \\\"$context.identity.caller\\\", \\\"user\\\" : \\\"$context.identity.user\\\", \\\"user_arn\\\" : \\\"$context.identity.userArn\\\", \\\"integration_latency\\\": $context.integration.latency }\"\n      }\n    }\n  }\n}\n</code></pre> <pre><code>Resources:\n  Api:\n    Type: AWS::Serverless::HttpApi\n    Properties:\n      DefinitionUri: openapi.yaml\n      StageName: prod\n\n      # Setup logging for API Gateway\n      AccessLogSettings:\n        DestinationArn: \"arn:aws:logs:eu-west-1:123456789012:log-group:my-log-group\"\n        Format: |\n          {\n            \"stage\" : \"$context.stage\",\n            \"request_id\" : \"$context.requestId\",\n            \"api_id\" : \"$context.apiId\",\n            \"resource_path\" : \"$context.resourcePath\",\n            \"resource_id\" : \"$context.resourceId\",\n            \"http_method\" : \"$context.httpMethod\",\n            \"source_ip\" : \"$context.identity.sourceIp\",\n            \"user-agent\" : \"$context.identity.userAgent\",\n            \"account_id\" : \"$context.identity.accountId\",\n            \"api_key\" : \"$context.identity.apiKey\",\n            \"caller\" : \"$context.identity.caller\",\n            \"user\" : \"$context.identity.user\",\n            \"user_arn\" : \"$context.identity.userArn\",\n            \"integration_latency\": $context.integration.latency\n          }\n</code></pre> <pre><code>provider:\n  name: aws\n  logs:\n    httpApi:\n      format: |\n        {\n          \"stage\" : \"$context.stage\",\n          \"request_id\" : \"$context.requestId\",\n          \"api_id\" : \"$context.apiId\",\n          \"resource_path\" : \"$context.resourcePath\",\n          \"resource_id\" : \"$context.resourceId\",\n          \"http_method\" : \"$context.httpMethod\",\n          \"source_ip\" : \"$context.identity.sourceIp\",\n          \"user-agent\" : \"$context.identity.userAgent\",\n          \"account_id\" : \"$context.identity.accountId\",\n          \"api_key\" : \"$context.identity.apiKey\",\n          \"caller\" : \"$context.identity.caller\",\n          \"user\" : \"$context.identity.user\",\n          \"user_arn\" : \"$context.identity.userArn\",\n          \"integration_latency\": $context.integration.latency\n        }\n</code></pre> <pre><code>resource \"aws_apigatewayv2_api\" \"this\" {\n  name          = \"my-api\"\n  protocol_type = \"HTTP\"\n  body          = file(\"openapi.yaml\") \n}\n\nresource \"aws_apigatewayv2_stage\" \"this\" {\n  api_id = aws_apigatewayv2_api.this.id\n  name   = \"prod\"\n\n  # Setup logging for API Gateway\n  access_log_settings {\n    destination_arn = \"arn:aws:logs:eu-west-1:123456789012:log-group:my-log-group\"\n    format = &lt;&lt;EOF\n{\n  \"stage\" : \"$context.stage\",\n  \"request_id\" : \"$context.requestId\",\n  \"api_id\" : \"$context.apiId\",\n  \"resource_path\" : \"$context.resourcePath\",\n  \"resource_id\" : \"$context.resourceId\",\n  \"http_method\" : \"$context.httpMethod\",\n  \"source_ip\" : \"$context.identity.sourceIp\",\n  \"user-agent\" : \"$context.identity.userAgent\",\n  \"account_id\" : \"$context.identity.accountId\",\n  \"api_key\" : \"$context.identity.apiKey\",\n  \"caller\" : \"$context.identity.caller\",\n  \"user\" : \"$context.identity.user\",\n  \"user_arn\" : \"$context.identity.userArn\",\n  \"integration_latency\": $context.integration.latency\n}\nEOF\n  }\n}\n</code></pre>"},{"location":"rules/api_gateway/logging/#see-also","title":"See also","text":"<ul> <li>Serverless Lens: Centralized and structured logging</li> <li>Monitoring REST APIs</li> <li>Monitoring your HTTP API</li> <li>Monitoring WebSocket APIs</li> </ul>"},{"location":"rules/api_gateway/structured_logging/","title":"API Gateway Structured Logging","text":"<p>Level: Warning</p> <p>Initial version: 0.1.3</p> <p>cfn-lint: WS2001</p> <p>tflint (REST): aws_api_gateway_stage_structured_logging</p> <p>tflint (HTTP): aws_apigatewayv2_stage_structured_logging</p> <p>You can customize the log format that Amazon API Gateway uses to send logs. Structured logging makes it easier to derive queries to answer arbitrary questions about the health of your application.</p>"},{"location":"rules/api_gateway/structured_logging/#why-is-this-a-warning","title":"Why is this a warning?","text":"<p>The rule in <code>serverless-rules</code> only checks if the structured log is JSON-formatted.</p> <p>While CloudWatch Logs Insights will automatically discover fields in JSON log entries, you can use the <code>parse</code> command to parse custom log entries to extract fields from custom format.</p>"},{"location":"rules/api_gateway/structured_logging/#implementations","title":"Implementations","text":"<p>See the implementations for Logging on API Gateway.</p>"},{"location":"rules/api_gateway/structured_logging/#see-also","title":"See also","text":"<ul> <li>Serverless Lens: Centralized and structured logging</li> <li>Monitoring REST APIs</li> <li>Monitoring your HTTP API</li> <li>Monitoring WebSocket APIs</li> <li>Amazon CloudWatch Logs: Supported Logs and Discovered Fields</li> <li>Amazon CloudWatch Logs: Logs Insights Query Syntax</li> </ul>"},{"location":"rules/api_gateway/tracing/","title":"API Gateway Tracing","text":"<p>Level: Warning</p> <p>Initial version: 0.1.3</p> <p>cfn-lint: WS2002</p> <p>tflint (REST): aws_apigateway_stage_tracing_rule</p> <p>tflint (HTTP): Not supported</p> <p>Amazon API Gateway can emit traces to AWS X-Ray, which enable visualizing service maps for faster troubleshooting.</p>"},{"location":"rules/api_gateway/tracing/#implementations-for-rest-apis","title":"Implementations for REST APIs","text":"CDKCloudFormation (JSON)CloudFormation (YAML)Serverless FrameworkTerraform <pre><code>import { RestApi } from '@aws-cdk/aws-apigateway';\n\nexport class MyStack extends cdk.Stack {\n  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    const myApi = new RestApi(\n      scope, 'MyApi',\n      {\n        // Enable tracing on API Gateway\n        deployOptions: {\n          tracingEnabled: true,\n        },\n      }\n    );\n  }\n}\n</code></pre> <pre><code>{\n  \"Resources\": {\n    \"Api\": {\n      \"Type\": \"AWS::Serverless::Api\",\n      \"Properties\": {\n        \"DefinitionUri\": \"openapi.yaml\",\n        \"StageName\": \"prod\",\n\n        // Enable tracing on API Gateway\n        \"TracingEnabled\": true\n      }\n    }\n  }\n}\n</code></pre> <pre><code>Resources:\n  Api:\n    Type: AWS::Serverless::Api\n    Properties:\n      DefinitionUri: openapi.yaml\n      StageName: prod\n\n      # Enable tracing on API Gateway\n      TracingEnabled: true\n</code></pre> <pre><code>provider:\n  name: aws\n  # Enable tracing on API Gateway\n  tracing:\n    apiGateway: true\n</code></pre> <pre><code>resource \"aws_api_gateway_rest_api\" \"this\" {\n  body = file(\"openapi.yaml\")\n}\n\nresource \"aws_api_gateway_deployment\" \"this\" {\n  rest_api_id = aws_api_gateway_rest_api.this.id\n\n  triggers = {\n    redeployment = sha1(jsonencode(aws_api_gateway_rest_api.this.body))\n  }\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n\nresource \"aws_api_gateway_stage\" \"this\" {\n  deployment_id = aws_api_gateway_deployment.this.id\n  rest_api_id   = aws_api_gateway_rest_api.this.id\n  stage_name    = \"prod\"\n\n  # Enable tracing on API Gateway\n  xray_tracing_enabled = true\n}\n</code></pre>"},{"location":"rules/api_gateway/tracing/#implementations-for-http-apis","title":"Implementations for HTTP APIs","text":"<p>Remark: HTTP APIs do not support tracing at the moment.</p>"},{"location":"rules/api_gateway/tracing/#why-is-this-a-warning","title":"Why is this a warning?","text":"<p>You might use third party solutions for monitoring serverless applications. If this is the case, enabling tracing for API Gateway might be optional. Refer to the documentation of your monitoring solutions to see if you should enable AWS X-Ray tracing or not.</p>"},{"location":"rules/api_gateway/tracing/#see-also","title":"See also","text":"<ul> <li>Serverless Lens: Distributed Tracing</li> <li>Tracing user requests to REST APIs using X-Ray</li> </ul>"},{"location":"rules/appsync/tracing/","title":"AppSync Tracing","text":"<p>Level: Warning</p> <p>Initial version: 0.1.3</p> <p>cfn-lint: WS3000</p> <p>tflint: aws_appsync_graphql_api_tracing_rule</p> <p>AWS AppSync can emit traces to AWS X-Ray, which enables visualizing service maps for faster troubleshooting.</p>"},{"location":"rules/appsync/tracing/#why-is-this-a-warning","title":"Why is this a warning?","text":"<p>You might use third party solutions for monitoring serverless applications. If this is the case, enabling tracing for AppSync APIs might be optional. Refer to the documentation of your monitoring solutions to see if you should enable AWS X-Ray tracing or not.</p>"},{"location":"rules/appsync/tracing/#implementations","title":"Implementations","text":"CDKCloudFormation (JSON)CloudFormation (YAML)Serverless FrameworkTerraform <pre><code>import { GraphqlApi } from '@aws-cdk/aws-appsync';\n\nexport class MyStack extends cdk.Stack {\n  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    const myApi = new GraphqlApi(\n      scope, 'MyApi',\n      {\n        name: 'my-api',\n        // Enable active tracing\n        xrayEnabled: true,\n      }\n    );\n  }\n}\n</code></pre> <pre><code>{\n  \"Resources\": {\n    \"GraphQLApi\": {\n    \"Type\": \"AWS::AppSync::GraphQLApi\",\n    \"Properties\": {\n      \"Name\": \"api\",\n      \"AuthenticationType\": \"AWS_IAM\",\n\n      // Enable active tracing\n      \"XrayEnabled\": true\n    }\n    }\n  }\n}\n</code></pre> <pre><code>Resources:\n  GraphQLApi:\n    Type: AWS::AppSync::GraphQLApi\n    Properties:\n      Name: api\n      AuthenticationType: AWS_IAM\n\n      # Enable active tracing\n      XrayEnabled: true\n</code></pre> <pre><code>resources:\n  Resources:\n    GraphQLApi:\n      Type: AWS::AppSync::GraphQLApi\n      Properties:\n        Name: api\n        AuthenticationType: AWS_IAM\n\n        # Enable active tracing\n        XrayEnabled: true\n</code></pre> <pre><code>resource \"aws_appsync_graphql_api\" \"this\" {\n  name                = \"api\"\n  authentication_type = \"AWS_IAM\"\n\n  # Enable active tracing\n  xray_enabled = true\n}\n</code></pre>"},{"location":"rules/appsync/tracing/#see-also","title":"See also","text":"<ul> <li>Serverless Lens: Distributed Tracing</li> <li>Tracing with AWS X-Ray</li> </ul>"},{"location":"rules/eventbridge/rule_without_dlq/","title":"EventBridge Rule without DLQ","text":"<p>Level: Error</p> <p>Initial version: 0.1.3</p> <p>cfn-lint: ES4000</p> <p>tflint: aws_cloudwatch_event_target_no_dlq</p> <p>Sometimes, an event isn't successfully delivered to the target(s) specified in a rule. By default, EventBridge will retry for 24 hours and up to 185 times, but you can customize the retry policy.</p> <p>If EventBridge cannot deliver an event after all its retries, it can send it to a dead-letter queue. You can then inspect the event and remediate the underlying issue.</p>"},{"location":"rules/eventbridge/rule_without_dlq/#implementations","title":"Implementations","text":"CDKCloudFormation (JSON)CloudFormation (YAML)Serverless FrameworkTerraform <pre><code>import { Function } from '@aws-cdk/aws-lambda';\nimport { Rule } from '@aws-cdk/aws-events';\nimport * as targets from '@aws-cdk/aws-events-targets';\n\nexport class MyStack extends cdk.Stack {\n  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    const myFunction = new Function(\n      scope, 'MyFunction',\n      {\n        code: Code.fromAsset('src/hello/'),\n        handler: 'main.handler',\n        runtime: Runtime.PYTHON_3_8,\n      }\n    );\n\n    const myRule = new Rule(\n      scope, 'MyRule',\n      {\n        eventPattern: {\n          source: ['my-source'],\n        }\n      }\n    );\n\n    myRule.addTarget(new targets.LambdaFunction(\n      myfunction,\n      // Add a DLQ to the 'myFunction' target\n      {\n        deadLetterQueue: myQueue,\n      }\n    ));\n  }\n}\n</code></pre> <pre><code>{\n  \"Resources\": {\n    \"MyRule\": {\n      \"Type\": \"AWS::Events::Rule\",\n      \"Properties\": {\n        \"EventBusName\": \"default\",\n        \"EventPattern\": \"{\\\"source\\\": [\\\"my-source\\\"]}\",\n        \"Targets\": [{\n          \"Id\": \"MyFunction\",\n          \"Arn\": \"arn:aws:lambda:us-east-1:111122223333:function:MyFunction\",\n          // Add a DLQ to the 'MyFunction' target\n          \"DeadLetterConfig\": {\n            \"Arn\": \"arn:aws:sqs:us-east-1:111122223333:dlq\"\n          }\n        }]\n      }\n    }\n  }\n}\n</code></pre> <pre><code>Resources:\n  MyRule:\n    Type: AWS::Events::Rule\n    Properties:\n      EventBusName: default\n      EventPattern: |\n        {\n          \"source\": [\"my-source\"]\n        }\n      Targets:\n        - Id: MyFunction\n          Arn: arn:aws:lambda:us-east-1:111122223333:function:MyFunction\n          # Add a DLQ to the 'MyFunction' target\n          DeadLetterConfig:\n            Arn: arn:aws:sqs:us-east-1:111122223333:dlq\n</code></pre> <pre><code>resources:\n  Resources:\n    MyRule:\n      Type: AWS::Events::Rule\n      Properties:\n        EventBusName: default\n        EventPattern: |\n          {\n            \"source\": [\"my-source\"]\n          }\n        Targets:\n          - Id: MyFunction\n            Arn: arn:aws:lambda:us-east-1:111122223333:function:MyFunction\n            # Add a DLQ to the 'MyFunction' target\n            DeadLetterConfig:\n              Arn: arn:aws:sqs:us-east-1:111122223333:dlq\n</code></pre> <pre><code>resource \"aws_cloudwatch_event_rule\" \"this\" {\n  event_pattern = &lt;&lt;EOF\n{\n  \"source\": [\"my-source\"]\n}\nEOF\n}\n\nresource \"aws_cloudwatch_event_target\" \"this\" {\n  rule      = aws_cloudwatch_event_rule.this.name\n  target_id = \"MyFunction\"\n  arn       = \"arn:aws:lambda:us-east-1:111122223333:function:MyFunction\"\n\n  # Add a DLQ to the 'MyFunction' target\n  dead_letter_config {\n    arn = \"arn:aws:sqs:us-east-1:111122223333:dlq\"\n  }\n}\n</code></pre>"},{"location":"rules/eventbridge/rule_without_dlq/#see-also","title":"See also","text":"<ul> <li>Event retry policy and using dead-letter queues</li> </ul>"},{"location":"rules/lambda/async_failure_destination/","title":"Lambda Async Failure Destination","text":"<p>Level: Error</p> <p>Initial version: 0.1.8</p> <p>cfn-lint: ES1007</p> <p>tflint: aws_lambda_event_invoke_config_async_on_failure</p> <p>Several AWS services, such as Amazon S3, Amazon SNS, or Amazon EventBridge, invoke Lambda functions asynchronously to process events. When you invoke a function asynchronously, you don't wait for a response from the function code. You hand off the event to Lambda and Lambda handles the rest.</p> <p>When an asynchronous calls fail, they should be captured and retried whenever possible. For this purpose, you can set a destination where Lambda will send events for successful or failed invocations.</p> Matching function name between resources <p>This rule works by comparing Lambda Permission resources with Lambda Event Invoke Config resources. For this rule to work correctly, you must set the function name on both resources in the exact same way.</p> <p>For example, in CloudFormation, if you use the <code>Fn::Ref</code> intrinsic function to refer to your Lambda function on both resources, this rule will work normally. If you use <code>Fn::Ref</code> on one, and <code>Fn::Join</code> on another, this rule will not work.</p> <p>Here are some examples of valid implementation in CloudFormation:</p> With Fn::RefWith Fn::SubWith a static value <pre><code>Resources:\n  Permission:\n    Type: AWS::Lambda::Permission\n    Properties:\n      # Other properties omitted\n      FunctionName: !Ref MyFunction\n\n  EventInvokeConfig:\n    Type: AWS::Lambda::EventInvokeConfig\n    Properties:\n      # Other properties omitted\n      FunctionName: !Ref MyFunction\n</code></pre> <pre><code>Resources:\n  Permission:\n    Type: AWS::Lambda::Permission\n    Properties:\n      # Other properties omitted\n      FunctionName: !Sub \"arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:${MyFunction}\"\n\n  EventInvokeConfig:\n    Type: AWS::Lambda::EventInvokeConfig\n    Properties:\n      # Other properties omitted\n      FunctionName: !Sub \"arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:${MyFunction}\"\n</code></pre> <pre><code>Resources:\n  Permission:\n    Type: AWS::Lambda::Permission\n    Properties:\n      # Other properties omitted\n      FunctionName: my-lambda-function\n\n  EventInvokeConfig:\n    Type: AWS::Lambda::EventInvokeConfig\n    Properties:\n      # Other properties omitted\n      FunctionName: my-lambda-function\n</code></pre> <p>By comparison, this implementation will return an error:</p> With mixed references <pre><code>Resources:\n  Permission:\n    Type: AWS::Lambda::Permission\n    Properties:\n      # Other properties omitted\n      FunctionName: !Ref MyFunction\n\n  EventInvokeConfig:\n    Type: AWS::Lambda::EventInvokeConfig\n    Properties:\n      # Other properties omitted\n      FunctionName: my-lambda-function\n</code></pre> Disabled for Terraform <p>This rule is disabled for Terraform, as the current linter only support static values in expressions. See this issue for more information.</p>"},{"location":"rules/lambda/async_failure_destination/#implementations","title":"Implementations","text":"CDKCloudFormation (JSON)CloudFormation (YAML)Serverless FrameworkTerraform <pre><code>import { Code, Function, Runtime } from '@aws-cdk/aws-lambda';\nimport { SnsEventSource } from '@aws-cdk/aws-lambda-event-sources';\nimport { SqsDestination } from '@aws-cdk/aws-lambda-destinations';\nimport { Topic } from '@aws-cdk/aws-sns';\n\nexport class MyStack extends cdk.Stack {\n  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    const myTopic = new Topic(\n      scope, 'MyTopic',\n    );\n\n    const myDLQ = new Queue(\n      scope, 'MyDLQ',\n    );\n\n    const myFunction = new Function(\n      scope, 'MyFunction',\n      {\n        code: Code.fromAsset('src/hello/'),\n        handler: 'main.handler',\n        runtime: Runtime.PYTHON_3_8,\n\n        onFailure: new SqsDestination(myDLQ),\n      }\n    );\n\n    // SNS will trigger the function asynchronously\n    myFunction.addEventSource(new SnsEventSource(myTopic));\n\n\n  }\n}\n</code></pre> <pre><code>{\n  \"Resources\": {\n    \"SNSFunction\": {\n      \"Type\": \"AWS::Serverless::Function\",\n      \"Properties\": {\n        \"CodeUri\": \".\",\n        // SNS will trigger the function asynchronously\n        \"Events\": {\n          \"SNS\": {\n            \"Type\": \"SNS\",\n            \"Properties\": {\n              \"Topic\": \"my-sns-topic\"\n            }\n          }\n        },\n        // Configure a failure destination for the function\n        \"EventInvokeConfig\": {\n          \"DestinationConfig\": {\n            \"OnFailure\": {\n              \"Type\": \"SQS\",\n              \"Destination\": \"arn:aws:sqs:us-east-1:111122223333:my-dlq\"\n            }\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre> <pre><code>SNSFunction:\n  Type: AWS::Serverless::Function\n  Properties:\n    CodeUri: .\n    # SNS will trigger the function asynchronously\n    Events:\n      SNS:\n        Type: SNS\n        Properties:\n          Topic: my-sns-topic\n    # Configure a failure destination for the function\n    EventInvokeConfig:\n      DestinationConfig:\n        OnFailure:\n          Type: SQS\n          Destination: arn:aws:sqs:us-east-1:111122223333:my-dlq\n</code></pre> <pre><code>functions:\n  hello:\n    handler: main.handler\n    # SNS will trigger the function asynchronously\n    events:\n      - sns:\n          topicName: my-sns-topic\n    # Configure a failure destination for the function\n    destinations:\n      onFailure: arn:aws:sqs:us-east-1:111122223333:my-dlq\n</code></pre> <pre><code>resource \"aws_lambda_function\" \"this\" {\n  function_name = \"my-function\"\n  runtime       = \"python3.8\"\n  handler       = \"main.handler\"\n  filename      = \"function.zip\"\n}\n\nresource \"aws_lambda_permission\" \"this\" {\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.this.function_name\n  # Grants the permission to SNS to invoke this function\n  # SNS will trigger the function asynchronously\n  principal     = \"sns.amazonaws.com\"\n}\n\nresource \"aws_lambda_function_event_invoke_config\" \"example\" {\n  function_name = aws_lambda_alias.example.function_name\n\n  # Configure a failure destination for the function\n  destination_config {\n    on_failure {\n      destination = \"arn:aws:sqs:us-east-1:111122223333:my-dlq\"\n    }\n  }\n}\n</code></pre>"},{"location":"rules/lambda/async_failure_destination/#see-also","title":"See also","text":"<ul> <li>Asynchronous invocation</li> <li>Serverless Lens: Failure Management</li> <li>CloudFormation: AWS::Lambda::EventInvokeConfig</li> <li>Terraform: aws_lambda_function_event_invoke_config</li> </ul>"},{"location":"rules/lambda/default_memory_size/","title":"Lambda Default Memory Size","text":"<p>Level: Error</p> <p>Initial version: 0.1.8</p> <p>cfn-lint: ES1005</p> <p>tflint: aws_lambda_function_default_memory</p> <p>Lambda allocates CPU power in proportion to the amount of memory configured. By default, your functions have 128 MB of memory allocated. You can increase that value up to 10 GB. With more CPU resources, your Lambda function's duration might decrease.</p> <p>You can use tools such as AWS Lambda Power Tuning to test your function at different memory settings to find the one that matches your cost and performance requirements the best.</p>"},{"location":"rules/lambda/default_memory_size/#implementations","title":"Implementations","text":"CDKCloudFormation (JSON)CloudFormation (YAML)Serverless FrameworkTerraform <pre><code>import { Code, Function, Runtime } from '@aws-cdk/aws-lambda';\n\nexport class MyStack extends cdk.Stack {\n  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    const myFunction = new Function(\n      scope, 'MyFunction',\n      {\n        code: Code.fromAsset('src/hello/'),\n        handler: 'main.handler',\n        runtime: Runtime.PYTHON_3_8,\n        // Change the function memory size\n        memorySize: 2048,\n      }\n    );\n  }\n}\n</code></pre> <pre><code>{\n  \"Resources\": {\n    \"MyFunction\": {\n      \"Type\": \"AWS::Serverless::Function\",\n      \"Properties\": {\n        // Required properties\n        \"CodeUri\": \".\",\n        \"Runtime\": \"python3.8\",\n        \"Handler\": \"main.handler\",\n\n        // Change the function memory size\n        \"MemorySize\": 2048\n      }\n    }\n  }\n}\n</code></pre> <pre><code>Resources:\n  MyFunction:\n    Type: AWS::Serverless::Function\n    Properties:\n      # Required properties\n      CodeUri: .\n      Runtime: python3.12\n      Handler: main.handler\n\n      # Change the function memory size\n      MemorySize: 2048\n</code></pre> <pre><code>provider:\n  name: aws\n  # Change the memory size across all functions\n  memorySize: 2048\n\nfunctions:\n  hello:\n    handler: handler.hello\n    # Change the memory size for one function\n    memorySize: 512\n</code></pre> <pre><code>resource \"aws_lambda_function\" \"this\" {\n  function_name = \"my-function\"\n  runtime       = \"python3.8\"\n  handler       = \"main.handler\"\n  filename      = \"function.zip\"\n\n  # Change the default memory size value\n  memory_size = 2048\n}\n</code></pre>"},{"location":"rules/lambda/default_memory_size/#see-also","title":"See also","text":"<ul> <li>Configuring Lambda function memory</li> <li>Serverless Lens: Optimize</li> <li>AWS Lambda Power Tuning</li> <li>CloudFormation: AWS::Lambda::Function</li> <li>Terraform: aws_lambda_function</li> </ul>"},{"location":"rules/lambda/default_timeout/","title":"Lambda Default Timeout","text":"<p>Level: Error</p> <p>Initial version: 0.1.8</p> <p>cfn-lint: ES1006</p> <p>tflint: aws_lambda_function_default_timeout</p> <p>You can define the timeout value, which restricts the maximum duration of a single invocation of your Lambda functions.</p> <p>If your timeout value is too short, Lambda might terminate invocations prematurely. On the other side, setting the timeout much higher than the average execution may cause functions to execute for longer upon code malfunction, resulting in higher costs and possibly reaching concurrency limits depending on how such functions are invoked.</p>"},{"location":"rules/lambda/default_timeout/#implementations","title":"Implementations","text":"CDKCloudFormation (JSON)CloudFormation (YAML)Serverless FrameworkTerraform <pre><code>import { Code, Function, Runtime } from '@aws-cdk/aws-lambda';\n\nexport class MyStack extends cdk.Stack {\n  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    const myFunction = new Function(\n      scope, 'MyFunction',\n      {\n        code: Code.fromAsset('src/hello/'),\n        handler: 'main.handler',\n        runtime: Runtime.PYTHON_3_8,\n        // Change the function timeout\n        timeout: 10,\n      }\n    );\n  }\n}\n</code></pre> <pre><code>{\n  \"Resources\": {\n    \"MyFunction\": {\n      \"Type\": \"AWS::Serverless::Function\",\n      \"Properties\": {\n        // Required properties\n        \"CodeUri\": \".\",\n        \"Runtime\": \"python3.8\",\n        \"Handler\": \"main.handler\",\n\n        // Change the function timeout\n        \"Timeout\": 10\n      }\n    }\n  }\n}\n</code></pre> <pre><code>Resources:\n  MyFunction:\n    Type: AWS::Serverless::Function\n    Properties:\n      # Required properties\n      CodeUri: .\n      Runtime: python3.12\n      Handler: main.handler\n\n      # Change the function timeout\n      Timeout: 10\n</code></pre> <pre><code>provider:\n  name: aws\n  # Change the timeout across all functions\n  timeout: 10\n\nfunctions:\n  hello:\n    handler: handler.hello\n    # Change the timeout for one function\n    timeout: 15\n</code></pre> <pre><code>resource \"aws_lambda_function\" \"this\" {\n  function_name = \"my-function\"\n  runtime       = \"python3.8\"\n  handler       = \"main.handler\"\n  filename      = \"function.zip\"\n\n  # Change the function timeout\n  timeout = 10\n}\n</code></pre>"},{"location":"rules/lambda/default_timeout/#see-also","title":"See also","text":"<ul> <li>AWS Lambda execution environment</li> <li>Serverless Lens: Optimize</li> <li>CloudFormation: AWS::Lambda::Function</li> <li>Terraform: aws_lambda_function</li> </ul>"},{"location":"rules/lambda/end_of_life_runtime/","title":"Lambda End-of-life Runtime","text":"<p>Level: Error</p> <p>Initial version: 0.1.7</p> <p>cfn-lint: E2531</p> <p>tflint: aws_lambda_function_eol_runtime</p> <p>Managed Lambda runtimes for .zip file archives are built around a combination of operating system, programming language, and software libraries that are subject to maintenance and security updates. When security updates are no longer available for a component of a runtime, Lambda deprecates the runtime.</p> <p>Info</p> <p>This rule is implemented natively in <code>cfn-lint</code> as rule number E2531.</p>"},{"location":"rules/lambda/end_of_life_runtime/#implementations","title":"Implementations","text":"CDKCloudFormation (JSON)CloudFormation (YAML)Serverless FrameworkTerraform <pre><code>import { Code, Function, Runtime } from '@aws-cdk/aws-lambda';\n\nexport class MyStack extends cdk.Stack {\n  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    const myFunction = new Function(\n      scope, 'MyFunction',\n      {\n        code: Code.fromAsset('src/hello/'),\n        handler: 'main.handler',\n        // Select a runtime that is not deprecated\n        runtime: Runtime.PYTHON_3_8,\n      }\n    );\n  }\n}\n</code></pre> <pre><code>{\n  \"Resources\": {\n    \"MyFunction\": {\n      \"Type\": \"AWS::Serverless::Function\",\n      \"Properties\": {\n        \"CodeUri\": \".\",\n        // Select a runtime that is not deprecated\n        \"Runtime\": \"python3.8\",\n        \"Handler\": \"main.handler\"\n      }\n    }\n  }\n}\n</code></pre> <pre><code>Resources:\n  MyFunction:\n    Type: AWS::Serverless::Function\n    Properties:\n      CodeUri: .\n      # Select a runtime that is not deprecated\n      Runtime: python3.12\n      Handler: main.handler\n</code></pre> <pre><code>provider:\n  name: aws\n  # Select a runtime that is not deprecated\n  runtime: nodejs14.x\n\nfunctions:\n  hello:\n    handler: handler.hello\n</code></pre> <pre><code>resource \"aws_lambda_function\" \"this\" {\n  function_name = \"my-function\"\n  # Select a runtime that is not deprecated\n  runtime       = \"python3.8\"\n  handler       = \"main.handler\"\n  filename      = \"function.zip\"\n}\n</code></pre>"},{"location":"rules/lambda/end_of_life_runtime/#see-also","title":"See also","text":"<ul> <li>Runtime support policy</li> </ul>"},{"location":"rules/lambda/eventsourcemapping_failure_destination/","title":"Lambda EventSourceMapping Failure Destination","text":"<p>Level: Error</p> <p>Initial version: 0.1.6</p> <p>cfn-lint: ES1001</p> <p>tflint: aws_lambda_event_source_mapping_failure_destination</p> <p>An AWS Lambda event source mapping reads from streams and poll-based event sources to invoke your functions. You can configure the event source mapping to send invocation records to another service such as Amazon SNS or Amazon SQS when it discards an event batch.</p>"},{"location":"rules/lambda/eventsourcemapping_failure_destination/#implementations","title":"Implementations","text":"CDKCloudFormation (JSON)CloudFormation (YAML)Serverless FrameworkTerraform <pre><code>import { EventSourceMapping, SqsDlq, StartingPosition } from '@aws-cdk/aws-lambda';\n\nexport class MyStack extends cdk.Stack {\n  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    new EventSourceMapping(scope, \"MyEventSourceMapping\", {\n      target: myFunction,\n      eventSourceArn: 'arn:aws:dynamodb:us-east-1:111122223333:table/my-table/stream/my-stream',\n      startingPosition: StartingPosition.LATEST,\n      onFailure: SqsDlq(mySqsQueue),\n    });\n  }\n}\n</code></pre> <pre><code>{\n  \"Resource\": {\n    \"MyEventSourceMapping\": {\n      \"Type\": \"AWS::Lambda::EventSourceMapping\",\n      \"Properties\": {\n        // Required properties\n        \"FunctionName\": \"my-function\",\n        \"EventSourceArn\": \"arn:aws:dynamodb:us-east-1:111122223333:table/my-table/stream/my-stream\",\n        \"StartingPosition\": \"LATEST\",\n\n        // Add an OnFailure destination on the event source mapping\n        \"DestinationConfig\": {\n          \"OnFailure\": {\n            \"Destination\": \"arn:aws:sqs:us-east-1:111122223333:my-dlq\"\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre> <pre><code>Resources:\n  MyEventSourceMapping:\n    Type: AWS::Lambda::EventSourceMapping\n    Properties:\n      # Required properties\n      FunctionName: my-function\n      EventSourceArn: arn:aws:dynamodb:us-east-1:111122223333:table/my-table/stream/my-stream\n      StartingPosition: LATEST\n\n      # Add an OnFailure destination on the event source mapping\n      DestinationConfig:\n        OnFailure:\n          Destination: arn:aws:sqs:us-east-1:111122223333:my-dlq \n</code></pre> <pre><code>functions:\n  MyFunction:\n    handler: hello.handler\n\nresources:\n  Resources:\n    MyEventSourceMapping:\n      Type: AWS::Lambda::EventSourceMapping\n      Properties:\n        # Required properties\n        FunctionName:\n          Fn::Ref: MyFunction\n        EventSourceArn: arn:aws:dynamodb:us-east-1:111122223333:table/my-table/stream/my-stream\n        StartingPosition: LATEST\n\n        # Add an OnFailure destination on the event source mapping\n        DestinationConfig:\n          OnFailure:\n            Destination: arn:aws:sqs:us-east-1:111122223333:my-dlq \n</code></pre> <pre><code>resource \"aws_lambda_event_source_mapping\" \"this\" {\n  # Required fields\n  event_source_arn  = \"arn:aws:dynamodb:us-east-1:111122223333:table/my-table/stream/my-stream\"\n  function_name     = \"my-function\"\n  starting_position = \"LATEST\"\n\n  # Add an OnFailure destination on the event source mapping\n  destination_config {\n    on_failure {\n      destination_arn = \"arn:aws:sqs:us-east-1:111122223333:my-dlq\"\n    }\n  }\n}\n</code></pre>"},{"location":"rules/lambda/eventsourcemapping_failure_destination/#see-also","title":"See also","text":"<ul> <li>AWS Lambda event source mappings</li> <li>CloudFormation: AWS::Lambda::EventSourceMapping</li> <li>Terraform: aws_lambda_event_source_mapping</li> </ul>"},{"location":"rules/lambda/log_retention/","title":"Lambda Log Retention","text":"<p>Level: Warning</p> <p>Initial version: 0.1.3</p> <p>cfn-lint: WS1004</p> <p>tflint: aws_cloudwatch_log_group_lambda_retention</p> <p>By default, CloudWatch log groups created by Lambda functions have an unlimited retention time. For cost optimization purposes, you should set a retention duration on all log groups. For log archival, export and set cost-effective storage classes that best suit your needs.</p> Referencing the function name in the log group <p>This rule works by matching a Lambda function name in the CloudWatch log group name. For CloudFormation, it supports <code>Fn::Join</code>, <code>Fn::Sub</code>, and hard-coding the Lambda function name into the log group name.</p> <p>Here are some examples of valid implementations:</p> With Fn::JoinWith Fn::SubWith function name <pre><code>Resources:\n  Function:\n    Type: AWS::Serverless::Function\n    Properties:\n      # Omitting other properties\n\n  LogGroup:\n    Type: AWS::Logs::LogGroup\n    Properties:\n      LogGroupName:\n        Fn::Join:\n        - \"\"\n        - - \"/aws/lambda/\"\n          - !Ref Function\n      RetentionInDays: 7\n</code></pre> <pre><code>Resources:\n  Function:\n    Type: AWS::Serverless::Function\n    Properties:\n      # Omitting other properties\n\n  LogGroup:\n    Type: AWS::Logs::LogGroup\n    Properties:\n      LogGroupName: !Sub \"/aws/lambda/${Function}\"\n      RetentionInDays: 7\n</code></pre> <pre><code>Resources:\n  Function:\n    Type: AWS::Serverless::Function\n    Properties:\n      # Omitting other properties\n      FunctionName: my_function_name\n\n  LogGroup:\n    Type: AWS::Logs::LogGroup\n    Properties:\n      LogGroupName: \"/aws/lambda/my_function_name\n      RetentionInDays: 7\n</code></pre> Disabled for Terraform <p>This rule is disabled for Terraform, as the current linter only support static values in expressions. See this issue for more information.</p>"},{"location":"rules/lambda/log_retention/#why-is-this-a-warning","title":"Why is this a warning?","text":"<p>Since <code>serverless-rules</code> evaluate infrastructure-as-code template, it cannot check if you use a solution that will automatically change the configuration of log groups after the fact.</p>"},{"location":"rules/lambda/log_retention/#implementations","title":"Implementations","text":"CDKCloudFormation (JSON)CloudFormation (YAML)Serverless FrameworkTerraform <pre><code>import { Code, Function, Runtime } from '@aws-cdk/aws-lambda';\nimport { LogGroup, RetentionDays } from '@aws-cdk/aws-logs';\n\nexport class MyStack extends cdk.Stack {\n  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    const myFunction = new Function(\n      scope, 'MyFunction',\n      {\n        code: Code.fromAsset('src/hello/'),\n        handler: 'main.handler',\n        runtime: Runtime.PYTHON_3_8,\n      }\n    );\n\n    // Explicit log group that refers to the Lambda function\n    const myLogGroup = new LogGroup(\n      scope, 'MyLogGroup',\n      {\n        logGroupName: `/aws/lambda/${myFunction.functionName}`,\n        retention: RetentionDays.ONE_WEEK,\n      }\n    );\n  }\n}\n</code></pre> <pre><code>{\n  \"Resources\": {\n    // Lambda function\n    \"Function\": {\n      \"Type\": \"AWS::Serverless::Function\",\n      \"Properties\": {\n        \"CodeUri\": \".\",\n        \"Runtime\": \"python3.8\",\n        \"Handler\": \"main.handler\",\n        \"Tracing\": \"Active\"\n      }\n    },\n\n    // Explicit log group that refers to the Lambda function\n    \"LogGroup\": {\n      \"Type\": \"AWS::Logs::LogGroup\",\n      \"Properties\": {\n        \"LogGroupName\": {\n          \"Fn::Sub\": \"/aws/lambda/${Function}\"\n        },\n        // Explicit retention time\n        \"RetentionInDays\": 7\n      }\n    }\n  }\n}\n</code></pre> <pre><code>Resources:\n  Function:\n    Type: AWS::Serverless::Function\n    Properties:\n      CodeUri: .\n      Runtime: python3.12\n      Handler: main.handler\n      Tracing: Active\n\n  # Explicit log group that refers to the Lambda function\n  LogGroup:\n    Type: AWS::Logs::LogGroup\n    Properties:\n      LogGroupName: !Sub \"/aws/lambda/${Function}\"\n      # Explicit retention time\n      RetentionInDays: 7\n</code></pre> <pre><code>provider:\n  name: aws\n  Runtime: python3.12\n  lambdaHashingVersion: '20201221'\n  # This will automatically create the log group with retention\n  logRetentionInDays: 14\n\nfunctions:\n  hello:\n    handler: handler.hello\n</code></pre> <pre><code>resource \"aws_lambda_function\" \"this\" {\n  function_name = \"my-function\"\n  handler       = \"main.handler\"\n  runtime       = \"python3.8\"\n  filename      = \"function.zip\"\n  role          = \"arn:aws:iam::111122223333:role/my-function-role\"\n}\n\n# Explicit log group\nresource \"aws_cloudwatch_log_group\" \"this\" {\n  name              = \"/aws/lambda/${aws_lambda_function.this.function_name}\n  # Explicit retention time\n  retention_in_days = 7\n}\n</code></pre>"},{"location":"rules/lambda/log_retention/#see-also","title":"See also","text":"<ul> <li>Serverless Lens: Logging Ingestion and Storage</li> <li>CloudFormation: AWS::Logs::LogGroup</li> <li>Terraform: aws_cloudwatch_log_group</li> </ul>"},{"location":"rules/lambda/permission_multiple_principals/","title":"Lambda Permission Multiple Principals","text":"<p>Level: Warning</p> <p>Initial version: 0.1.3</p> <p>cfn-lint: WS1002</p> <p>tflint: aws_lambda_permission_multiple_principals</p> <p>You can use resource-based policies to grant permission to other AWS services to invoke your Lambda functions. Different AWS services usually send different payloads to Lambda functions. If multiple services can invoke the same function, this function needs to handle the different types of payload properly, or this could cause unexpected behavior.</p> <p>In general, it's better to create multiple Lambda functions with different function handlers for each invocation source.</p>"},{"location":"rules/lambda/permission_multiple_principals/#implementations","title":"Implementations","text":"CDKCloudFormation (JSON)CloudFormation (YAML)Serverless FrameworkTerraform <pre><code>import { ServicePrincipal } from '@aws-cdk/aws-iam';\nimport { Function } from '@aws-cdk/aws-lambda';\nimport { SnsEventSource } from '@aws-cdk/aws-lambda-event-sources';\n\nexport class MyStack extends cdk.Stack {\n  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    const myFunction = new Function(\n      scope, 'MyFunction',\n      {\n        code: Code.fromAsset('src/hello/'),\n        handler: 'main.handler',\n        runtime: Runtime.PYTHON_3_8,\n      }\n    );\n\n    // This will implicitely grant those SNS topics the permission to invoke\n    // the Lambda function. As both come from SNS, this is a single principal\n    // ('sns.amazonaws.com') and thus will not trigger the rule.\n    myFunction.addEventSource(new SnsEventSource(myTopic1));\n    myFunction.addEventSource(new SnsEventSource(myTopic2));\n  }\n}\n</code></pre> <pre><code>{\n  \"Resources\": {\n    \"MyFunction\": {\n      \"Type\": \"AWS::Serverless::Function\",\n      \"Properties\": {\n        \"CodeUri\": \".\",\n        \"Runtime\": \"python3.8\",\n        \"Handler\": \"main.handler\",\n        // This will implicitely grant those SNS topics the permission to invoke\n        // the Lambda function. As both come from SNS, this is a single principal\n        // ('sns.amazonaws.com') and thus will not trigger the rule.\n        \"Events\": {\n          \"Topic1\": {\n            \"Type\": \"SNS\",\n            \"Properties\": {\n              \"Topic\": arn:aws:sns:us-east-1:111122223333:topic1\n            }\n          }\n          \"Topic2\": {\n            \"Type\": \"SNS\",\n            \"Properties\": {\n              \"Topic\": arn:aws:sns:us-east-1:111122223333:topic2\n            }\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre> <pre><code>Resources:\n  MyFunction:\n    Type: AWS::Serverless::Function\n    Properties:\n      CodeUri: .\n      Runtime: python3.12\n      Handler: main.handler\n      Tracing: Active\n      # This will implicitely grant those SNS topics the permission to invoke\n      # the Lambda function. As both come from SNS, this is a single principal\n      # ('sns.amazonaws.com') and thus will not trigger the rule.\n      Events:\n        Topic1:\n          Type: SNS\n          Properties:\n            Topic: arn:aws:sns:us-east-1:111122223333:topic1\n        Topic2:\n          Type: SNS\n          Properties:\n            Topic: arn:aws:sns:us-east-1:111122223333:topic2\n</code></pre> <pre><code>functions:\n  hello:\n    handler: handler.hello\n    # This will implicitely grant those SNS topics the permission to invoke\n    # the Lambda function. As both come from SNS, this is a single principal\n    # ('sns.amazonaws.com') and thus will not trigger the rule.\n    events:\n      - sns: topic1\n      - sns: topic2\n</code></pre> <pre><code>resource \"aws_iam_role\" \"this\" {\n  name = \"my-function-role\"\n  assume_role_policy = data.aws_iam_policy_document.assume.json\n\n  inline_policy {\n    name = \"FunctionPolicy\"\n    policy = data.aws_iam_policy_document.this.json\n  }\n}\n\ndata \"aws_iam_policy_document\" \"assume\" {\n  statement {\n    actions = [\"sts:AssumeRole\"]\n    principals {\n      type       = \"Service\"\n      identifiers = [\"lambda.amazonaws.com\"]\n    }\n  }\n}\n\ndata \"aws_iam_policy_document\" \"this\" {\n  statement {\n    # Tightly scoped permissions to just 'dynamodb:Query'\n    # instead of 'dynamodb:*' or '*'\n    actions = [\"dynamodb:Query\"]\n    resources = [\"arn:aws:dynamodb:eu-west-1:111122223333:table/my-table\"]\n  }\n}\n\nresource \"aws_lambda_function\" \"this\" {\n  function_name = \"my-function\"\n  handler       = \"main.handler\"\n  runtime       = \"python3.8\"\n  filename      = \"function.zip\"\n  role          = aws_iam_role.this.arn\n}\n\n# Add a Lambda permission for Amazon EventBridge\nresource \"aws_lambda_permission\" \"this\" {\n  statement_id  = \"AllowExecutionFromEventBridge\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.this.function_name\n  principal     = \"events.amazonaws.com\"\n}\n</code></pre>"},{"location":"rules/lambda/permission_multiple_principals/#why-is-this-a-warning","title":"Why is this a warning?","text":"<p>You might have a valid reason for invoking a Lambda function from different event sources or AWS services. If this is the case and you know what you are doing, you might ignore this rule.</p>"},{"location":"rules/lambda/permission_multiple_principals/#see-also","title":"See also","text":"<ul> <li>Using resource-based policies for AWS Lambda</li> </ul>"},{"location":"rules/lambda/star_permissions/","title":"Lambda Star Permissions","text":"<p>Level: Warning</p> <p>Initial version: 0.1.3</p> <p>cfn-lint: WS1003</p> <p>tflint: aws_iam_role_lambda_no_star</p> <p>With Lambda functions, you should follow least-privileged access and only allow the access needed to perform a given operation. Attaching a role with more permissions than necessary can open up your systems for abuse.</p> Limitations on policies <p>This rule only works with inline policies defined as part of the IAM role resource. It will not check managed policies or policies defined as separate resources.</p> CloudFormationTerraform <pre><code>Resources:\n  MyRole:\n    Type: AWS::IAM::Role\n    Properties:\n      AssumeRolePolicyDocument:\n        Version: \"2012-10-17\"\n        Statement:\n          - Effect: Allow\n            Principal:\n              Service:\n                - lambda.amazonaws.com\n            Action:\n              - sts:AssumeRole\n      # The rule will check this policy\n      Policies:\n        - PolicyName: root\n          PolicyDocument:\n            Version: \"2012-10-17\"\n            Statement:\n              - Effect: Allow\n                Action: dynamodb:Query\n                Resource: \"*\"\n\n  # It will not check this policy\n  MyPolicy:\n    Type: AWS::IAM::Policy\n    Properties:\n      PolicyDocument:\n        Version: \"2012-10-17\"\n            Statement:\n              - Effect: Allow\n                Action: dynamodb:*\n                Resource: \"*\"\n      Roles:\n        - !GetAtt MyRole.Arn\n</code></pre> <pre><code>resource \"aws_iam_role\" \"this\" {\n  name = \"my-function-role\"\n  assume_role_policy = data.aws_iam_policy_document.assume.json\n\n  # The rule will check this policy\n  inline_policy {\n    name = \"FunctionPolicy\"\n    policy = data.aws_iam_policy_document.valid.json\n  }\n}\n\n# It will not check this policy\nresource \"aws_iam_policy\" \"this\" {\n  policy = data.aws_iam_policy_document.invalid.json\n}\n\nresource \"aws_iam_policy_attachment\" \"this\" {\n  roles = [aws_iam_role.this.name]\n  policy_arn = aws_iam_policy.this.arn\n}\n\ndata \"aws_iam_policy_document\" \"assume\" {\n  statement {\n    actions = [\"sts:AssumeRole\"]\n    principals {\n      type       = \"Service\"\n      identifiers = [\"lambda.amazonaws.com\"]\n    }\n  }\n}\n\ndata \"aws_iam_policy_document\" \"valid\" {\n  statement {\n    actions = [\"dynamodb:Query\"]\n    resources = [\"arn:aws:dynamodb:eu-west-1:111122223333:table/my-table\"]\n  }\n}\n\ndata \"aws_iam_policy_document\" \"invalid\" {\n  statement {\n    actions = [\"dynamodb:*\"]\n    resources = [\"*\"]\n  }\n}\n</code></pre>"},{"location":"rules/lambda/star_permissions/#why-is-this-a-warning","title":"Why is this a warning?","text":"<p>If your Lambda function needs a broad range of permissions, you do not know ahead of time which permissions you will need, and you have evaluated the risks of using broad permissions for this function, you might ignore this rule.</p>"},{"location":"rules/lambda/star_permissions/#implementations","title":"Implementations","text":"CDKCloudFormation (JSON)CloudFormation (YAML)Serverless FrameworkTerraform <pre><code>import { AttributeType, Table } from '@aws-cdk/aws-dynamodb';\nimport { Code, Function, Runtime } from '@aws-cdk/aws-lambda';\n\nexport class MyStack extends cdk.Stack {\n  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    const myTable = new Table(\n      scope, 'MyTable',\n      {\n        partitionKey: {\n          name: 'id',\n          type: AttributeType.STRING,\n        }\n      },\n    );\n\n    const myFunction = new Function(\n      scope, 'MyFunction',\n      {\n        code: Code.fromAsset('src/hello/'),\n        handler: 'main.handler',\n        runtime: Runtime.PYTHON_3_8,\n      }\n    );\n\n    // Grant read access to the DynamoDB table\n    table.grantReadData(myFunction);\n  }\n}\n</code></pre> <pre><code>{\n  \"Resources\": {\n    \"MyFunction\": {\n      \"Type\": \"AWS::Serverless::Function\",\n      \"Properties\": {\n        \"CodeUri\": \".\",\n        \"Runtime\": \"python3.8\",\n        \"Handler\": \"main.handler\",\n\n        \"Policies\": [{\n          \"Version\": \"2012-10-17\",\n          \"Statement\": [{\n            \"Effect\": \"Allow\",\n            // Tightly scoped permissions to just 's3:GetObject'\n            // instead of 's3:*' or '*'\n            \"Action\": \"s3:GetObject\",\n            \"Resource\": \"arn:aws:s3:::my-bucket/*\"\n          }]\n        }]\n      }\n    }\n  }\n}\n</code></pre> <pre><code>Resources:\n  MyFunction:\n    Type: AWS::Serverless::Function\n    Properties:\n      CodeUri: .\n      Runtime: python3.12\n      Handler: main.handler\n\n      Policies:\n        - Version: \"2012-10-17\"\n          Statement:\n            - Effect: Allow\n              # Tightly scoped permissions to just 's3:GetObject'\n              # instead of 's3:*' or '*'\n              Action: s3:GetObject\n              Resource: \"arn:aws:s3:::my-bucket/*\"\n</code></pre> <pre><code>provider:\n  name: aws\n  iam:\n    role:\n      name: my-function-role\n      statements:\n        - Effect: Allow\n          # Tightly scoped permissions to just 's3:GetObject'\n          # instead of 's3:*' or '*'\n          Action: s3:GetObject\n          Resource: \"arn:aws:s3:::my-bucket/*\"\n\nfunctions:\n  hello:\n    handler: handler.hello\n</code></pre> <pre><code>resource \"aws_iam_role\" \"this\" {\n  name = \"my-function-role\"\n  assume_role_policy = data.aws_iam_policy_document.assume.json\n\n  inline_policy {\n    name = \"FunctionPolicy\"\n    policy = data.aws_iam_policy_document.this.json\n  }\n}\n\ndata \"aws_iam_policy_document\" \"assume\" {\n  statement {\n    actions = [\"sts:AssumeRole\"]\n    principals {\n      type       = \"Service\"\n      identifiers = [\"lambda.amazonaws.com\"]\n    }\n  }\n}\n\ndata \"aws_iam_policy_document\" \"this\" {\n  statement {\n    # Tightly scoped permissions to just 'dynamodb:Query'\n    # instead of 'dynamodb:*' or '*'\n    actions = [\"dynamodb:Query\"]\n    resources = [\"arn:aws:dynamodb:eu-west-1:111122223333:table/my-table\"]\n  }\n}\n\nresource \"aws_lambda_function\" \"this\" {\n  function_name = \"my-function\"\n  handler       = \"main.handler\"\n  runtime       = \"python3.8\"\n  filename      = \"function.zip\"\n  role          = aws_iam_role.this.arn\n}\n</code></pre>"},{"location":"rules/lambda/star_permissions/#see-also","title":"See also","text":"<ul> <li>Serverless Lens: Identity and Access Management</li> <li>AWS Lambda execution role</li> </ul>"},{"location":"rules/lambda/tracing/","title":"Lambda Tracing","text":"<p>Level: Warning</p> <p>Initial version: 0.1.3</p> <p>cfn-lint: WS1000</p> <p>tflint: aws_lambda_function_tracing_rule</p> <p>AWS Lambda can emit traces to AWS X-Ray, which enables visualizing service maps for faster troubleshooting.</p>"},{"location":"rules/lambda/tracing/#why-is-this-a-warning","title":"Why is this a warning?","text":"<p>You might use third party solutions for monitoring serverless applications. If this is the case, enabling tracing for your AWS Lambda functions might be optional. Refer to the documentation of your monitoring solutions to see if you should enable AWS X-Ray tracing or not.</p>"},{"location":"rules/lambda/tracing/#implementations","title":"Implementations","text":"CDKCloudFormation (JSON)CloudFormation (YAML)Serverless FrameworkTerraform <pre><code>import { Code, Function, Runtime, Tracing } from '@aws-cdk/aws-lambda';\n\nexport class MyStack extends cdk.Stack {\n  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    const myFunction = new Function(\n      scope, 'MyFunction',\n      {\n        code: Code.fromAsset('src/hello/'),\n        handler: 'main.handler',\n        runtime: Runtime.PYTHON_3_8,\n        // Enable active tracing\n        tracing: Tracing.ACTIVE,\n      }\n    );\n  }\n}\n</code></pre> <pre><code>{\n  \"Resources\": {\n    \"MyFunction\": {\n      \"Type\": \"AWS::Serverless::Function\",\n      \"Properties\": {\n        // Required properties\n        \"CodeUri\": \".\",\n        \"Runtime\": \"python3.8\",\n        \"Handler\": \"main.handler\",\n\n        // Enable active tracing\n        \"Tracing\": \"Active\"\n      }\n    }\n  }\n}\n</code></pre> <pre><code>Resources:\n  MyFunction:\n    Type: AWS::Serverless::Function\n    Properties:\n      # Required properties\n      CodeUri: .\n      Runtime: python3.12\n      Handler: main.handler\n\n      # Enable active tracing\n      Tracing: Active\n</code></pre> <pre><code>provider:\n  tracing:\n    # Enable active tracing for Lambda functions\n    lambda: true\n\nfunctions:\n  hello:\n    handler: handler.hello\n</code></pre> <pre><code>resource \"aws_lambda_function\" \"this\" {\n  function_name = \"my-function\"\n  runtime       = \"python3.8\"\n  handler       = \"main.handler\"\n  filename      = \"function.zip\"\n\n  # Enable active tracing\n  tracing_config {\n    mode = \"Active\"\n  }\n}\n</code></pre>"},{"location":"rules/lambda/tracing/#see-also","title":"See also","text":"<ul> <li>Serverless Lens: Distributed Tracing</li> <li>Using AWS Lambda with X-Ray</li> </ul>"},{"location":"rules/sns/redrive_policy/","title":"SNS Redrive Policy","text":"<p>Level: Error</p> <p>Initial version: 0.1.7</p> <p>cfn-lint: ES7000</p> <p>tflint: aws_sns_topic_subscription_redrive_policy</p> <p>You can configure the redrive policy on an Amazon SNS subscription. If SNS cannot deliver the message after the number of attempts set in its delivery policy, SNS will send it to the dead-letter queue specified in the redrive policy.</p>"},{"location":"rules/sns/redrive_policy/#implementations","title":"Implementations","text":"CDKCloudFormation (JSON)CloudFormation (YAML)Serverless FrameworkTerraform <pre><code>import { Queue } from '@aws-cdk/aws-sqs';\nimport { Topic } from '@aws-cdk/aws-sns';\nimport { UrlSubscription } from '@aws-cdk-aws-sns-subscriptions';\n\nexport class MyStack extends cdk.Stack {\n  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    // Dead letter queue\n    const myDLQ = new Queue(\n      scope, 'MyDLQ',\n    );\n\n    // SNS Topic\n    const myTopic = new Topic(scope, 'MyTopic');\n\n    // Adding an URL subscription\n    myTopic.addSubscription(new UrlSubscription(\n      'https://example.com',\n      {\n        // Configure the redrive policy for the subscription\n        deadLetterQueue: myDLQ,\n      }\n    ));\n  }\n}\n</code></pre> <pre><code>{\n  \"Resources\": {\n    \"MySubscription\": {\n    \"Type\": \"AWS::SNS::Subscription\",\n    \"Properties\": {\n      \"Protocol\": \"https\",\n      \"Endpoint\": \"https://example.com/\"\n      \"TopicArn\": \"my-topic-arn\",\n\n      // Configure the redrive policy for the subscription\n      \"RedrivePolicy\": \"{ \\\"deadLetterTargetArn\\\": \\\"arn:aws:sqs:us-east-2:123456789012:MyDeadLetterQueue\\\"}\"\n      }\n    }\n  }\n}\n</code></pre> <pre><code>Resources:\n  MySubscription:\n    Type: AWS::SNS::Subscription\n    Properties:\n      Protocol: https\n      Endpoint: https://example.com/\n      TopicArn: \"my-topic-arn\"\n\n      # Configure the redrive policy for the subscription\n      RedrivePolicy: |\n        {\n          \"deadLetterTargetArn\": \"arn:aws:sqs:us-east-2:123456789012:MyDeadLetterQueue\"\n        }\n</code></pre> <pre><code># For subscriptions to Lambda function endpoints\nfunctions:\n  MyFunction:\n    handler: hello.handler\n    events:\n      - sns:\n          topicName: my-topic\n          # Configure the redrive policy for the subscription to the Lambda function\n          redrivePolicy:\n            deadLetterTargetArn: arn:aws:sqs:us-east-2:123456789012:MyDeadLetterQueue\n\n# For subscriptions to other types of endpoint\nresources:\n  Resources:\n    MySubscription:\n      Type: AWS::SNS::Subscription\n      Properties:\n        Protocol: https\n        Endpoint: https://example.com/\n        TopicArn: \"my-topic-arn\"\n\n        # Configure the redrive policy for the subscription to another type of resource\n        RedrivePolicy: |\n          {\n            \"deadLetterTargetArn\": \"arn:aws:sqs:us-east-2:123456789012:MyDeadLetterQueue\"\n          }\n</code></pre> <pre><code>resource \"aws_sns_topic_subscription\" \"this\" {\n  endpoint = \"https://example.com/\"\n  protocol = \"https\"\n  topic_arn = \"my-topic-arn\"\n\n  # Configure the redrive policy for the subscription\n  redrive_policy = &lt;&lt;EOF\n{\n  \"deadLetterTargetArn\": \"arn:aws:sqs:us-east-2:123456789012:MyDeadLetterQueue\"\n}\nEOF\n}\n</code></pre>"},{"location":"rules/sns/redrive_policy/#see-also","title":"See also","text":"<ul> <li>Amazon SNS message delivery retries</li> <li>Amazon SNS dead-letter queues (DLQs)</li> <li>CloudFormation: AWS::SNS::Subscription</li> <li>Terraform: aws_sns_topic_subscription</li> </ul>"},{"location":"rules/sqs/redrive_policy/","title":"SQS Redrive Policy","text":"<p>Level: Error</p> <p>Initial version: 0.1.7</p> <p>cfn-lint: ES6000</p> <p>tflint: aws_sqs_queue_redrive_policy</p> <p>You can configure the redrive policy on an Amazon SQS queue. With a redrive policy, you can define how many times SQS will make the messages available for consumers. After that, SQS will send it to the dead-letter queue specified in the policy.</p> Disabled for Terraform <p>This rule is disabled for Terraform, as the current linter only support static values in expressions. See this issue for more information.</p>"},{"location":"rules/sqs/redrive_policy/#implementations","title":"Implementations","text":"CDKCloudFormation (JSON)CloudFormation (YAML)Serverless FrameworkTerraform <pre><code>import { Queue } from '@aws-cdk/aws-sqs';\n\nexport class MyStack extends cdk.Stack {\n  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    // Dead letter queue\n    const myDLQ = new Queue(\n      scope, \"MyDLQ\",\n    );\n\n    const myQueue = new Queue(\n      scope, \"MyQueue\",\n      {\n        // Configure the redrive policy for MyQueue\n        deadLetterQueue: {\n          maxReceiveCount: 4,\n          queue: myDLQ,\n        },\n      }\n    );\n  }\n}\n</code></pre> <pre><code>{\n  \"Resources\": {\n    \"MyQueue\": {\n      \"Type\": \"AWS::SQS::Queue\",\n      \"Properties\": {\n        // Configure the redrive policy for MyQueue\n        \"RedrivePolicy\": \"{ \\\"deadLetterTargetArn\\\": \\\"arn:aws:sqs:us-east-2:111122224444:my-dlq\\\", \\\"maxReceiveCount\\\": 4 }\"\n      }\n    }\n  }\n}\n</code></pre> <pre><code>Resources:\n  MyQueue:\n    Type: AWS::SQS::Queue\n    Properties:\n      # Configure the redrive policy for MyQueue\n      RedrivePolicy: |\n        {\n          \"deadLetterTargetArn\": \"arn:aws:sqs:us-east-2:111122224444:my-dlq\",\n          \"maxReceiveCount\": 4\n        }\n</code></pre> <pre><code>resources:\n  Resources:\n    MyQueue:\n      Type: AWS::SQS::Queue\n      Properties:\n        # Configure the redrive policy for MyQueue\n        RedrivePolicy: |\n          {\n            \"deadLetterTargetArn\": \"arn:aws:sqs:us-east-2:111122224444:my-dlq\",\n            \"maxReceiveCount\": 4\n          }\n</code></pre> <pre><code>resource \"aws_sqs_queue\" \"this\" {\n  # Configure the redrive policy for the queue\n  redrive_policy = jsonencode({\n    deadLetterTargetArn = \"arn:aws:sqs:us-east-2:111122224444:my-dlq\"\n    maxReceiveCount     = 4\n  })\n}\n</code></pre>"},{"location":"rules/sqs/redrive_policy/#see-also","title":"See also","text":"<ul> <li>Serverless Lens: Failure Management</li> <li>Amazon SQS dead-letter-queues</li> <li>CloudFormation: AWS::SQS::Queue</li> <li>Terraform: aws_sqs_queue</li> </ul>"},{"location":"rules/step_functions/tracing/","title":"Step Functions Tracing","text":"<p>Level: Warning</p> <p>Initial version: 0.1.3</p> <p>cfn-lint: WS5000</p> <p>tflint: aws_sfn_state_machine_tracing</p> <p>AWS Step Functions can emit traces to AWS X-Ray, which enables visualizing service maps for faster troubleshooting.</p>"},{"location":"rules/step_functions/tracing/#why-is-this-a-warning","title":"Why is this a warning?","text":"<p>You might use third party solutions for monitoring serverless applications. If this is the case, enabling tracing for Step Functions might be optional. Refer to the documentation of your monitoring solutions to see if you should enable AWS X-Ray tracing or not.</p>"},{"location":"rules/step_functions/tracing/#implementations","title":"Implementations","text":"CDKCloudFormation (JSON)CloudFormation YAMLServerless FrameworkTerraform <pre><code>import { Function } from '@aws-cdk/aws-lambda';\nimport { StateMachine } from '@aws-cdk/aws-stepfunctions';\nimport * as tasks from '@aws-cdk/aws-stepfunctions-\n\nexport class MyStack extends cdk.Stack {\n  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    const myFunction = new Function(\n      scope, 'MyFunction',\n      {\n        code: Code.fromAsset('src/hello/'),\n        handler: 'main.handler',\n        runtime: Runtime.PYTHON_3_8,\n      }\n    );\n\n    const myJob = tasks.LambdaInvoke(\n      scope, 'MyJob',\n      {\n        lambdaFunction: myFunction,\n      },\n    );\n\n    const myStateMachine = new StateMachine(\n      scope, 'MyStateMachine',\n      {\n        definition: myJob,\n        // Enable tracing on Step Functions\n        tracingEnabled: true,\n      }\n    );\n  }\n}\n</code></pre> <pre><code>{\n  \"Resources\": {\n    \"StateMachine\": {\n      \"Type\": \"AWS::StepFunctions::StateMachine\",\n      \"Properties\": {\n        \"DefinitionString\": \"{ \\\"StartAt\\\": \\\"HelloWorld\\\", \\\"States\\\": { \\\"HelloWorld\\\": { \\\"Type\\\": \\\"Task\\\", \\\"Resource\\\": \\\"arn:aws:lambda:us-east-1:111122223333:function:HelloFunction\\\", \\\"End\\\": \\\"true\\\" }}}\",\n        \"RoleArn\": \"arn:aws:iam::111122223333:role/service-role/StatesExecutionRole\",\n\n        // Enable active tracing for Step Functions\n        \"TracingConfiguration\": {\n          \"Enabled\": true\n        }\n      }\n    }\n  }\n}\n</code></pre> <pre><code>Resources:\n  StateMachine:\n    Type: AWS::StepFunctions::StateMachine\n    Properties:\n      DefinitionString: |\n        {\n          \"StartAt\": \"HelloWorld\",\n          \"States\": {\n            \"HelloWorld\": {\n              \"Type\": \"Task\",\n              \"Resource\": \"arn:aws:lambda:us-east-1:111122223333:function:HelloFunction\",\n              \"End\": \"true\"\n            }\n          }\n        }\n      RoleArn: arn:aws:iam::111122223333:role/service-role/StatesExecutionRole\n\n      # Enable active tracing for Step Functions\n      TracingConfiguration:\n        Enabled: true\n</code></pre> <pre><code>resources:\n  Resources:\n    StateMachine:\n      Type: AWS::StepFunctions::StateMachine\n      Properties:\n        DefinitionString: |\n          {\n            \"StartAt\": \"HelloWorld\",\n            \"States\": {\n              \"HelloWorld\": {\n                \"Type\": \"Task\",\n                \"Resource\": \"arn:aws:lambda:us-east-1:111122223333:function:HelloFunction\",\n                \"End\": \"true\"\n              }\n            }\n          }\n        RoleArn: arn:aws:iam::111122223333:role/service-role/StatesExecutionRole\n\n        # Enable active tracing for Step Functions\n        TracingConfiguration:\n          Enabled: true\n</code></pre> <pre><code>resource \"aws_sfn_state_machine\" \"this\" {\n  name     = \"my-state-machine\"\n  role_arn = \"arn:aws:iam::111122223333:role/my-state-machine-role\"\n\n  definition = &lt;&lt;EOF\n{\n  \"StartAt\": \"HelloWorld\",\n  \"States\": {\n    \"HelloWorld\": {\n      \"Type\": \"Task\",\n      \"Resource\": \"arn:aws:lambda:us-east-1:111122223333:function:HelloFunction\",\n      \"End\": \"true\"\n    }\n  }\n}\nEOF\n\n  # Enable active tracing for Step Functions\n  tracing_configuration {\n    enabled = true\n  }\n}\n</code></pre>"},{"location":"rules/step_functions/tracing/#see-also","title":"See also","text":"<ul> <li>Serverless Lens: Distributed Tracing</li> <li>AWS X-Ray and Step Functions</li> </ul>"}]}